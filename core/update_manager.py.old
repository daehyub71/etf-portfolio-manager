# ==========================================
# core/update_manager.py - ETF ì—…ë°ì´íŠ¸ ê´€ë¦¬ì (pykrx ì—°ë™ ë²„ì „)
# ==========================================

import pandas as pd
import numpy as np
import sqlite3
import time
import json
import logging
import os
from datetime import datetime, timedelta
from typing import Dict, List, Tuple
from dataclasses import dataclass, asdict
import sys

# í”„ë¡œì íŠ¸ ëª¨ë“ˆ import
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# MarketDataCollector import ì‹œë„
try:
    from data.market_data_collector import MarketDataCollector
    MARKET_DATA_AVAILABLE = True
    print("âœ… MarketDataCollector ì‚¬ìš© ê°€ëŠ¥")
except ImportError as e:
    MARKET_DATA_AVAILABLE = False
    print(f"âš ï¸ MarketDataCollector import ì‹¤íŒ¨: {e}")
    
    # ë”ë¯¸ MarketDataCollector
    class MarketDataCollector:
        def __init__(self, db_path):
            self.db_path = db_path
            print(f"ğŸ”§ ë”ë¯¸ MarketDataCollector ì‚¬ìš©")
        
        def get_all_etf_list(self):
            return [
                {'code': '069500', 'name': 'KODEX 200', 'market_price': 28400},
                {'code': '360750', 'name': 'TIGER ë¯¸êµ­S&P500', 'market_price': 15800},
                {'code': '114260', 'name': 'KODEX êµ­ê³ ì±„10ë…„', 'market_price': 108500},
            ]
        
        def fetch_etf_price_data(self, code, period="1m"):
            import pandas as pd
            import numpy as np
            # ë”ë¯¸ ê°€ê²© ë°ì´í„° ìƒì„±
            dates = pd.date_range(end=datetime.now(), periods=30, freq='D')
            prices = np.random.normal(10000, 500, 30)
            return pd.DataFrame({
                'date': dates,
                'close': prices,
                'returns': np.random.normal(0, 0.02, 30)
            })
        
        def calculate_performance_metrics(self, price_data):
            return {'data_points': len(price_data), 'volatility': 15.0}
        
        def fetch_etf_info(self, code):
            return {'current_price': 10000 + hash(code) % 5000, 'volume': 50000}
        
        def get_market_status(self):
            return {
                'last_business_day': '20241220',
                'is_trading_hours': False,
                'pykrx_available': False
            }

try:
    from data.etf_universe import ETFUniverse
    ETF_UNIVERSE_AVAILABLE = True
except ImportError as e:
    ETF_UNIVERSE_AVAILABLE = False
    print(f"âš ï¸ ETFUniverse import ì‹¤íŒ¨: {e}")

@dataclass
class UpdateResult:
    """ì—…ë°ì´íŠ¸ ê²°ê³¼ ë°ì´í„° í´ë˜ìŠ¤"""
    code: str
    name: str
    status: str  # 'success', 'failed', 'skipped'
    error_message: str = ""
    update_time: str = ""
    data_points: int = 0
    current_price: float = 0.0
    price_change: float = 0.0

@dataclass
class BatchUpdateSummary:
    """ì¼ê´„ ì—…ë°ì´íŠ¸ ìš”ì•½"""
    start_time: str
    end_time: str
    total_etfs: int
    successful_updates: int
    failed_updates: int
    skipped_updates: int
    success_rate: float
    total_duration: float
    results: List[UpdateResult]
    errors: List[str]

class ETFUpdateManager:
    """ETF ë°ì´í„° ì „ì²´ ì—…ë°ì´íŠ¸ ê´€ë¦¬ì (pykrx ì—°ë™ ë²„ì „)"""
    
    def __init__(self, db_path: str = "etf_universe.db", log_level: str = "INFO"):
        self.db_path = db_path
        
        # ë¡œê¹… ì„¤ì •
        self.setup_logging(log_level)
        self.logger = logging.getLogger(__name__)
        
        # ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™”
        self._initialize_database()
        
        # MarketDataCollector ì´ˆê¸°í™”
        self.collector = MarketDataCollector(db_path)
        
        # ì—…ë°ì´íŠ¸ ìƒíƒœ ì¶”ì 
        self.current_batch_id = None
        self.is_updating = False
        self.update_progress = 0
        self.update_status = "idle"
        
        # ë§ˆì§€ë§‰ ì‹¤ì œ ë°ì´í„° ë¡œë“œ ì‹œë„
        self.last_real_data_attempt = None
        self.use_real_data = MARKET_DATA_AVAILABLE
        
        self.logger.info("ETF ì—…ë°ì´íŠ¸ ê´€ë¦¬ì ì´ˆê¸°í™” ì™„ë£Œ")
    
    def setup_logging(self, level: str):
        """ë¡œê¹… ì„¤ì •"""
        logger = logging.getLogger()
        if not logger.handlers:
            log_format = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
            
            # ì½˜ì†” í•¸ë“¤ëŸ¬
            console_handler = logging.StreamHandler(sys.stdout)
            console_handler.setFormatter(logging.Formatter(log_format))
            logger.addHandler(console_handler)
            
            # íŒŒì¼ í•¸ë“¤ëŸ¬ (ì˜µì…˜)
            try:
                file_handler = logging.FileHandler('etf_updates.log', encoding='utf-8')
                file_handler.setFormatter(logging.Formatter(log_format))
                logger.addHandler(file_handler)
            except Exception as e:
                print(f"íŒŒì¼ ë¡œê¹… ì„¤ì • ì‹¤íŒ¨: {e}")
        
        logger.setLevel(getattr(logging, level.upper()))
    
    def _initialize_database(self):
        """ë°ì´í„°ë² ì´ìŠ¤ í…Œì´ë¸” ì´ˆê¸°í™”"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            # ETF ì •ë³´ í…Œì´ë¸” ìƒì„± (pykrx ë°ì´í„° êµ¬ì¡°ì— ë§ê²Œ)
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS etf_info (
                    code TEXT PRIMARY KEY,
                    name TEXT NOT NULL,
                    category TEXT,
                    subcategory TEXT,
                    asset_class TEXT,
                    region TEXT,
                    currency TEXT DEFAULT 'KRW',
                    expense_ratio REAL,
                    aum REAL DEFAULT 0,
                    market_price REAL DEFAULT 0,
                    nav REAL DEFAULT 0,
                    premium_discount REAL DEFAULT 0,
                    dividend_yield REAL DEFAULT 0,
                    tracking_error REAL DEFAULT 0,
                    benchmark TEXT,
                    fund_manager TEXT,
                    inception_date TEXT,
                    last_updated TEXT,
                    avg_volume INTEGER DEFAULT 0,
                    is_active BOOLEAN DEFAULT 1
                )
            ''')
            
            # ETF ê°€ê²© íˆìŠ¤í† ë¦¬ í…Œì´ë¸”
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS etf_price_history (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    code TEXT,
                    date TEXT,
                    open_price REAL,
                    high_price REAL,
                    low_price REAL,
                    close_price REAL,
                    volume INTEGER,
                    returns REAL,
                    FOREIGN KEY (code) REFERENCES etf_info(code),
                    UNIQUE(code, date)
                )
            ''')
            
            # ì—…ë°ì´íŠ¸ íˆìŠ¤í† ë¦¬ í…Œì´ë¸”
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS update_history (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    start_time TEXT,
                    end_time TEXT,
                    total_etfs INTEGER,
                    successful_updates INTEGER,
                    failed_updates INTEGER,
                    success_rate REAL,
                    total_duration REAL,
                    update_source TEXT,  -- 'pykrx' or 'dummy'
                    market_status TEXT,  -- JSON
                    summary_json TEXT
                )
            ''')
            
            conn.commit()
            conn.close()
            
            print(f"ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™” ì™„ë£Œ: {self.db_path}")
            
        except Exception as e:
            print(f"ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
    
    def refresh_etf_universe(self) -> bool:
        """ETF ìœ ë‹ˆë²„ìŠ¤ ìƒˆë¡œê³ ì¹¨ (pykrxì—ì„œ ìµœì‹  ëª©ë¡ ê°€ì ¸ì˜¤ê¸°)"""
        try:
            self.logger.info("ETF ìœ ë‹ˆë²„ìŠ¤ ìƒˆë¡œê³ ì¹¨ ì‹œì‘")
            
            # ì‹œì¥ ìƒíƒœ í™•ì¸
            market_status = self.collector.get_market_status()
            self.logger.info(f"ì‹œì¥ ìƒíƒœ: {market_status}")
            
            # ì „ì²´ ETF ë¦¬ìŠ¤íŠ¸ ê°€ì ¸ì˜¤ê¸°
            etf_list = self.collector.get_all_etf_list()
            
            if not etf_list:
                self.logger.warning("ETF ë¦¬ìŠ¤íŠ¸ê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤")
                return False
            
            # ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥
            success = self._save_etf_universe_to_db(etf_list, market_status)
            
            if success:
                self.logger.info(f"ETF ìœ ë‹ˆë²„ìŠ¤ ìƒˆë¡œê³ ì¹¨ ì™„ë£Œ: {len(etf_list)}ê°œ")
                return True
            else:
                self.logger.error("ETF ìœ ë‹ˆë²„ìŠ¤ ë°ì´í„°ë² ì´ìŠ¤ ì €ì¥ ì‹¤íŒ¨")
                return False
                
        except Exception as e:
            self.logger.error(f"ETF ìœ ë‹ˆë²„ìŠ¤ ìƒˆë¡œê³ ì¹¨ ì‹¤íŒ¨: {e}")
            return False
    
    def _save_etf_universe_to_db(self, etf_list: List[Dict], market_status: Dict) -> bool:
        """ETF ìœ ë‹ˆë²„ìŠ¤ë¥¼ ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            saved_count = 0
            
            for etf in etf_list:
                try:
                    cursor.execute('''
                        INSERT OR REPLACE INTO etf_info 
                        (code, name, category, market_price, aum, avg_volume, last_updated, is_active)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                    ''', (
                        etf['code'],
                        etf['name'],
                        etf.get('category', 'unknown'),
                        etf.get('market_price', 0),
                        etf.get('aum', 0),
                        etf.get('volume', 0),
                        etf.get('last_updated', datetime.now().isoformat()),
                        1  # is_active
                    ))
                    saved_count += 1
                    
                except Exception as e:
                    self.logger.warning(f"ETF {etf.get('code', 'unknown')} ì €ì¥ ì‹¤íŒ¨: {e}")
                    continue
            
            # ì‹œì¥ ìƒíƒœ ì •ë³´ë„ ë³„ë„ í…Œì´ë¸”ì— ì €ì¥ (ì„ íƒì )
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS market_status_log (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    timestamp TEXT,
                    status_json TEXT
                )
            ''')
            
            cursor.execute('''
                INSERT INTO market_status_log (timestamp, status_json)
                VALUES (?, ?)
            ''', (datetime.now().isoformat(), json.dumps(market_status)))
            
            conn.commit()
            conn.close()
            
            self.logger.info(f"ETF ìœ ë‹ˆë²„ìŠ¤ ì €ì¥ ì™„ë£Œ: {saved_count}ê°œ")
            return True
            
        except Exception as e:
            self.logger.error(f"ETF ìœ ë‹ˆë²„ìŠ¤ ì €ì¥ ì‹¤íŒ¨: {e}")
            return False
    
    def get_etf_list_from_db(self) -> List[Tuple[str, str]]:
        """ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ETF ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ"""
        try:
            conn = sqlite3.connect(self.db_path)
            
            # í™œì„± ETFë§Œ ì¡°íšŒ, AUMì´ í° ìˆœì„œë¡œ
            query = '''
                SELECT code, name FROM etf_info 
                WHERE is_active = 1 
                ORDER BY aum DESC, market_price DESC
            '''
            df = pd.read_sql_query(query, conn)
            conn.close()
            
            if df.empty:
                self.logger.warning("DBì—ì„œ ETF ë¦¬ìŠ¤íŠ¸ê°€ ë¹„ì–´ìˆìŒ - ìœ ë‹ˆë²„ìŠ¤ ìƒˆë¡œê³ ì¹¨ ì‹œë„")
                
                # ETF ìœ ë‹ˆë²„ìŠ¤ ìƒˆë¡œê³ ì¹¨ ì‹œë„
                if self.refresh_etf_universe():
                    # ë‹¤ì‹œ ì¡°íšŒ
                    conn = sqlite3.connect(self.db_path)
                    df = pd.read_sql_query(query, conn)
                    conn.close()
            
            if not df.empty:
                etf_list = list(zip(df['code'], df['name']))
                self.logger.info(f"DBì—ì„œ ETF ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ: {len(etf_list)}ê°œ")
                return etf_list
            else:
                # ê¸°ë³¸ ETF ë¦¬ìŠ¤íŠ¸ ë°˜í™˜
                return self._get_fallback_etf_list()
                
        except Exception as e:
            self.logger.error(f"DB ETF ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ ì‹¤íŒ¨: {e}")
            return self._get_fallback_etf_list()
    
    def _get_fallback_etf_list(self) -> List[Tuple[str, str]]:
        """ê¸°ë³¸ ETF ë¦¬ìŠ¤íŠ¸ (fallback)"""
        fallback_etfs = [
            ('069500', 'KODEX 200'),
            ('360750', 'TIGER ë¯¸êµ­S&P500'),
            ('114260', 'KODEX êµ­ê³ ì±„10ë…„'),
            ('133690', 'KODEX ë‚˜ìŠ¤ë‹¥100'),
            ('195930', 'KODEX ì„ ì§„êµ­MSCI'),
            ('229200', 'KODEX ì½”ìŠ¤ë‹¥150'),
            ('305080', 'TIGER ë¯¸êµ­ì±„10ë…„'),
            ('132030', 'KODEX ê³¨ë“œì„ ë¬¼'),
            ('329200', 'KODEX ë¦¬ì¸ '),
            ('305540', 'KODEX 2ì°¨ì „ì§€ì‚°ì—…')
        ]
        
        self.logger.info(f"ê¸°ë³¸ ETF ë¦¬ìŠ¤íŠ¸ ì‚¬ìš©: {len(fallback_etfs)}ê°œ")
        return fallback_etfs
    
    def update_single_etf(self, code: str, name: str, timeout: int = 30) -> UpdateResult:
        """ê°œë³„ ETF ì—…ë°ì´íŠ¸ (pykrx ë°ì´í„° ì‚¬ìš©)"""
        start_time = time.time()
        
        try:
            self.logger.info(f"{code} ({name}) ì—…ë°ì´íŠ¸ ì‹œì‘")
            
            # 1. ê°€ê²© ë°ì´í„° ìˆ˜ì§‘
            price_data = self.collector.fetch_etf_price_data(code, period="3m")
            
            if price_data.empty:
                return UpdateResult(
                    code=code,
                    name=name,
                    status="failed",
                    error_message="ê°€ê²© ë°ì´í„° ì—†ìŒ",
                    update_time=datetime.now().isoformat()
                )
            
            # 2. ì„±ê³¼ ì§€í‘œ ê³„ì‚°
            metrics = self.collector.calculate_performance_metrics(price_data)
            
            # 3. ETF ì¶”ê°€ ì •ë³´ ìˆ˜ì§‘
            etf_info = self.collector.fetch_etf_info(code)
            
            # 4. ë°ì´í„°ë² ì´ìŠ¤ ì—…ë°ì´íŠ¸
            success = self._update_database_with_real_data(code, price_data, metrics, etf_info)
            
            if success:
                # ê°€ê²© ë³€ë™ ê³„ì‚°
                if len(price_data) >= 2:
                    current_price = price_data['close'].iloc[-1]
                    prev_price = price_data['close'].iloc[-2]
                    price_change = ((current_price - prev_price) / prev_price) * 100
                else:
                    price_change = 0
                
                result = UpdateResult(
                    code=code,
                    name=name,
                    status="success",
                    update_time=datetime.now().isoformat(),
                    data_points=metrics.get('data_points', len(price_data)),
                    current_price=etf_info.get('current_price', 0),
                    price_change=round(price_change, 2)
                )
                
                duration = time.time() - start_time
                self.logger.info(f"{code} ì—…ë°ì´íŠ¸ ì„±ê³µ ({duration:.1f}ì´ˆ)")
                return result
            else:
                return UpdateResult(
                    code=code,
                    name=name,
                    status="failed",
                    error_message="ë°ì´í„°ë² ì´ìŠ¤ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨",
                    update_time=datetime.now().isoformat()
                )
                
        except Exception as e:
            error_msg = str(e)[:100]
            self.logger.error(f"{code} ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {error_msg}")
            
            return UpdateResult(
                code=code,
                name=name,
                status="failed",
                error_message=error_msg,
                update_time=datetime.now().isoformat()
            )
    
    def _update_database_with_real_data(self, code: str, price_data: pd.DataFrame, 
                                       metrics: dict, etf_info: dict) -> bool:
        """ì‹¤ì œ ë°ì´í„°ë¡œ ë°ì´í„°ë² ì´ìŠ¤ ì—…ë°ì´íŠ¸"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            current_time = datetime.now().isoformat()
            
            # ETF ê¸°ë³¸ ì •ë³´ ì—…ë°ì´íŠ¸
            cursor.execute('''
                UPDATE etf_info 
                SET market_price = ?, nav = ?, avg_volume = ?, last_updated = ?
                WHERE code = ?
            ''', (
                etf_info.get('current_price', 0),
                etf_info.get('nav', 0),
                etf_info.get('volume', 0),
                current_time,
                code
            ))
            
            # ê°€ê²© íˆìŠ¤í† ë¦¬ ì €ì¥ (ìµœê·¼ ë°ì´í„°ë§Œ)
            if not price_data.empty:
                # ìµœê·¼ 5ì¼ ë°ì´í„°ë§Œ ì €ì¥
                recent_data = price_data.tail(5)
                
                for _, row in recent_data.iterrows():
                    try:
                        date_str = row['date'].strftime('%Y-%m-%d') if hasattr(row['date'], 'strftime') else str(row['date'])[:10]
                        
                        cursor.execute('''
                            INSERT OR REPLACE INTO etf_price_history
                            (code, date, close_price, volume, returns)
                            VALUES (?, ?, ?, ?, ?)
                        ''', (
                            code,
                            date_str,
                            row.get('close', 0),
                            row.get('volume', 0),
                            row.get('returns', 0)
                        ))
                    except Exception as e:
                        self.logger.debug(f"ê°€ê²© íˆìŠ¤í† ë¦¬ ì €ì¥ ì‹¤íŒ¨: {e}")
                        continue
            
            conn.commit()
            conn.close()
            
            self.logger.debug(f"ETF {code} ë°ì´í„°ë² ì´ìŠ¤ ì—…ë°ì´íŠ¸ ì™„ë£Œ")
            return True
            
        except Exception as e:
            self.logger.error(f"ETF {code} ë°ì´í„°ë² ì´ìŠ¤ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}")
            return False
    
    def batch_update_all_etfs(self, 
                             max_etfs: int = None, 
                             delay_between_updates: float = 1.0,
                             max_failures: int = 10,
                             force_refresh_universe: bool = False) -> BatchUpdateSummary:
        """ì „ì²´ ETF ì¼ê´„ ì—…ë°ì´íŠ¸ (pykrx ë°ì´í„° ì‚¬ìš©)"""
        
        if self.is_updating:
            self.logger.warning("ì´ë¯¸ ì—…ë°ì´íŠ¸ê°€ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤")
            return None
        
        self.is_updating = True
        self.update_status = "running"
        start_time = datetime.now()
        
        try:
            # ì‹œì¥ ìƒíƒœ í™•ì¸
            market_status = self.collector.get_market_status()
            self.logger.info(f"ì‹œì¥ ìƒíƒœ: {market_status}")
            
            # ETF ìœ ë‹ˆë²„ìŠ¤ ìƒˆë¡œê³ ì¹¨ (ì˜µì…˜)
            if force_refresh_universe or self._should_refresh_universe():
                self.logger.info("ETF ìœ ë‹ˆë²„ìŠ¤ ìƒˆë¡œê³ ì¹¨ ì‹¤í–‰")
                self.refresh_etf_universe()
            
            # ETF ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ
            etf_list = self.get_etf_list_from_db()
            
            if max_etfs:
                etf_list = etf_list[:max_etfs]
            
            total_etfs = len(etf_list)
            self.logger.info(f"ì¼ê´„ ì—…ë°ì´íŠ¸ ì‹œì‘: {total_etfs}ê°œ ETF")
            
            print(f"\n{'='*60}")
            print(f"ğŸ“Š ETF ì¼ê´„ ì—…ë°ì´íŠ¸ ì‹œì‘ (pykrx ì—°ë™)")
            print(f"ëŒ€ìƒ ETF: {total_etfs}ê°œ")
            print(f"ì—…ë°ì´íŠ¸ ê°„ê²©: {delay_between_updates}ì´ˆ")
            print(f"ìµœëŒ€ ì‹¤íŒ¨ í—ˆìš©: {max_failures}ê°œ")
            print(f"ë°ì´í„° ì†ŒìŠ¤: {'pykrx (ì‹¤ì œ ë°ì´í„°)' if MARKET_DATA_AVAILABLE else 'Dummy (ì‹œë®¬ë ˆì´ì…˜)'}")
            print(f"ìµœì¢… ì˜ì—…ì¼: {market_status.get('last_business_day', 'Unknown')}")
            print(f"{'='*60}\n")
            
            # ì—…ë°ì´íŠ¸ ì‹¤í–‰
            results = []
            successful_count = 0
            failed_count = 0
            consecutive_failures = 0
            
            for i, (code, name) in enumerate(etf_list):
                self.update_progress = (i / total_etfs) * 100
                
                print(f"[{i+1:3d}/{total_etfs}] {code} ({name}) ì²˜ë¦¬ ì¤‘...")
                
                # ê°œë³„ ETF ì—…ë°ì´íŠ¸
                result = self.update_single_etf(code, name)
                results.append(result)
                
                if result.status == "success":
                    successful_count += 1
                    consecutive_failures = 0
                    price_info = f"{result.current_price:,.0f}ì›" if result.current_price > 0 else "ê°€ê²©ì •ë³´ì—†ìŒ"
                    change_info = f"({result.price_change:+.2f}%)" if result.price_change != 0 else ""
                    print(f"   âœ… ì„±ê³µ: {price_info} {change_info}")
                else:
                    failed_count += 1
                    consecutive_failures += 1
                    print(f"   âŒ ì‹¤íŒ¨: {result.error_message}")
                
                # ì—°ì† ì‹¤íŒ¨ ì²´í¬
                if consecutive_failures >= max_failures:
                    self.logger.error(f"ì—°ì† {max_failures}íšŒ ì‹¤íŒ¨ë¡œ ì—…ë°ì´íŠ¸ ì¤‘ë‹¨")
                    break
                
                # ì§„í–‰ë¥  í‘œì‹œ
                if (i + 1) % 5 == 0 or (i + 1) == total_etfs:
                    success_rate = (successful_count / (i + 1)) * 100
                    print(f"   ğŸ“Š ì§„í–‰ë¥ : {i+1}/{total_etfs} ({success_rate:.1f}% ì„±ê³µ)")
                
                # ì§€ì—°
                if i < len(etf_list) - 1:
                    time.sleep(delay_between_updates)
            
            # ìš”ì•½ ìƒì„±
            end_time = datetime.now()
            duration = (end_time - start_time).total_seconds()
            success_rate = (successful_count / len(results)) * 100 if results else 0
            
            summary = BatchUpdateSummary(
                start_time=start_time.isoformat(),
                end_time=end_time.isoformat(),
                total_etfs=len(results),
                successful_updates=successful_count,
                failed_updates=failed_count,
                skipped_updates=0,
                success_rate=round(success_rate, 1),
                total_duration=round(duration, 1),
                results=results,
                errors=[r.error_message for r in results if r.status == "failed" and r.error_message]
            )
            
            # ê²°ê³¼ ì¶œë ¥
            print(f"\n{'='*60}")
            print(f"ğŸ“ˆ ì¼ê´„ ì—…ë°ì´íŠ¸ ì™„ë£Œ!")
            print(f"ì†Œìš” ì‹œê°„: {duration/60:.1f}ë¶„")
            print(f"ì„±ê³µ: {successful_count}ê°œ")
            print(f"ì‹¤íŒ¨: {failed_count}ê°œ")
            print(f"ì„±ê³µë¥ : {success_rate:.1f}%")
            print(f"ë°ì´í„° ì†ŒìŠ¤: {'pykrx (ì‹¤ì œ)' if MARKET_DATA_AVAILABLE else 'Dummy (ì‹œë®¬ë ˆì´ì…˜)'}")
            print(f"{'='*60}")
            
            # ê²°ê³¼ ì €ì¥
            self.save_update_summary(summary, market_status)
            
            self.logger.info(f"ì¼ê´„ ì—…ë°ì´íŠ¸ ì™„ë£Œ: {success_rate:.1f}% ì„±ê³µ")
            return summary
            
        except Exception as e:
            self.logger.error(f"ì¼ê´„ ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜: {e}")
            raise
        finally:
            self.is_updating = False
            self.update_status = "idle"
            self.update_progress = 0
    
    def _should_refresh_universe(self) -> bool:
        """ETF ìœ ë‹ˆë²„ìŠ¤ ìƒˆë¡œê³ ì¹¨ì´ í•„ìš”í•œì§€ í™•ì¸"""
        try:
            conn = sqlite3.connect(self.db_path)
            
            # ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸ ì‹œê°„ í™•ì¸
            cursor = conn.execute('''
                SELECT MAX(last_updated) as last_update 
                FROM etf_info 
                WHERE last_updated IS NOT NULL
            ''')
            
            result = cursor.fetchone()
            conn.close()
            
            if not result or not result[0]:
                return True  # ë°ì´í„°ê°€ ì—†ìœ¼ë©´ ìƒˆë¡œê³ ì¹¨
            
            last_update = datetime.fromisoformat(result[0])
            hours_since_update = (datetime.now() - last_update).total_seconds() / 3600
            
            # 24ì‹œê°„ ì´ìƒ ì§€ë‚¬ìœ¼ë©´ ìƒˆë¡œê³ ì¹¨
            return hours_since_update >= 24
            
        except Exception as e:
            self.logger.warning(f"ìœ ë‹ˆë²„ìŠ¤ ìƒˆë¡œê³ ì¹¨ í•„ìš”ì„± í™•ì¸ ì‹¤íŒ¨: {e}")
            return False
    
    def save_update_summary(self, summary: BatchUpdateSummary, market_status: Dict = None):
        """ì—…ë°ì´íŠ¸ ìš”ì•½ ì €ì¥ (ì‹œì¥ ìƒíƒœ í¬í•¨)"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            # ì—…ë°ì´íŠ¸ ì†ŒìŠ¤ ê²°ì •
            update_source = 'pykrx' if MARKET_DATA_AVAILABLE else 'dummy'
            
            cursor.execute('''
                INSERT INTO update_history 
                (start_time, end_time, total_etfs, successful_updates, failed_updates, 
                 success_rate, total_duration, update_source, market_status, summary_json)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                summary.start_time,
                summary.end_time,
                summary.total_etfs,
                summary.successful_updates,
                summary.failed_updates,
                summary.success_rate,
                summary.total_duration,
                update_source,
                json.dumps(market_status) if market_status else None,
                json.dumps(asdict(summary), ensure_ascii=False, indent=2)
            ))
            
            conn.commit()
            conn.close()
            
            self.logger.info("ì—…ë°ì´íŠ¸ ìš”ì•½ ì €ì¥ ì™„ë£Œ")
            
        except Exception as e:
            self.logger.error(f"ì—…ë°ì´íŠ¸ ìš”ì•½ ì €ì¥ ì‹¤íŒ¨: {e}")
    
    def get_update_history(self, limit: int = 10) -> List[Dict]:
        """ì—…ë°ì´íŠ¸ íˆìŠ¤í† ë¦¬ ì¡°íšŒ"""
        try:
            conn = sqlite3.connect(self.db_path)
            query = '''
                SELECT * FROM update_history 
                ORDER BY start_time DESC 
                LIMIT ?
            '''
            df = pd.read_sql_query(query, conn, params=(limit,))
            conn.close()
            
            return df.to_dict('records')
            
        except Exception as e:
            self.logger.error(f"ì—…ë°ì´íŠ¸ íˆìŠ¤í† ë¦¬ ì¡°íšŒ ì‹¤íŒ¨: {e}")
            return []
    
    def get_current_status(self) -> Dict:
        """í˜„ì¬ ì—…ë°ì´íŠ¸ ìƒíƒœ ì¡°íšŒ"""
        market_status = self.collector.get_market_status()
        
        return {
            'is_updating': self.is_updating,
            'status': self.update_status,
            'progress': self.update_progress,
            'last_update': self.get_last_update_time(),
            'data_source': 'pykrx' if MARKET_DATA_AVAILABLE else 'dummy',
            'market_status': market_status
        }
    
    def get_last_update_time(self) -> str:
        """ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸ ì‹œê°„ ì¡°íšŒ"""
        try:
            conn = sqlite3.connect(self.db_path)
            query = "SELECT MAX(last_updated) as last_update FROM etf_info"
            result = pd.read_sql_query(query, conn).iloc[0]['last_update']
            conn.close()
            return result or "ì—…ë°ì´íŠ¸ ê¸°ë¡ ì—†ìŒ"
        except:
            return "ì—…ë°ì´íŠ¸ ê¸°ë¡ ì—†ìŒ"
    
    def quick_health_check(self) -> Dict:
        """ì‹œìŠ¤í…œ ìƒíƒœ ì²´í¬ (pykrx ì—°ë™ ìƒíƒœ í¬í•¨)"""
        try:
            conn = sqlite3.connect(self.db_path)
            
            # ê¸°ë³¸ í†µê³„
            stats = pd.read_sql_query('''
                SELECT 
                    COUNT(*) as total_etfs,
                    COUNT(CASE WHEN last_updated IS NOT NULL THEN 1 END) as updated_etfs,
                    COUNT(CASE WHEN market_price > 0 THEN 1 END) as price_available,
                    COUNT(CASE WHEN is_active = 1 THEN 1 END) as active_etfs
                FROM etf_info
            ''', conn).iloc[0]
            
            # ìµœê·¼ ì—…ë°ì´íŠ¸
            recent_updates = pd.read_sql_query('''
                SELECT COUNT(*) as recent_count
                FROM etf_info 
                WHERE last_updated > datetime('now', '-1 day')
            ''', conn).iloc[0]['recent_count']
            
            conn.close()
            
            health_score = (stats['updated_etfs'] / stats['total_etfs']) * 100 if stats['total_etfs'] > 0 else 0
            
            # ì‹œì¥ ìƒíƒœ ì •ë³´ ì¶”ê°€
            market_status = self.collector.get_market_status()
            
            return {
                'total_etfs': int(stats['total_etfs']),
                'updated_etfs': int(stats['updated_etfs']),
                'price_available': int(stats['price_available']),
                'active_etfs': int(stats['active_etfs']),
                'recent_updates_24h': int(recent_updates),
                'health_score': round(health_score, 1),
                'status': 'healthy' if health_score > 80 else 'warning' if health_score > 50 else 'critical',
                'data_source': 'pykrx' if MARKET_DATA_AVAILABLE else 'dummy',
                'last_business_day': market_status.get('last_business_day'),
                'is_trading_hours': market_status.get('is_trading_hours', False),
                'pykrx_available': market_status.get('pykrx_available', False)
            }
            
        except Exception as e:
            self.logger.error(f"ì‹œìŠ¤í…œ ìƒíƒœ ì²´í¬ ì‹¤íŒ¨: {e}")
            return {'status': 'error', 'error': str(e), 'health_score': 0.0}


# ==========================================
# ì‹¤í–‰ ì˜ˆì œ ë° í…ŒìŠ¤íŠ¸ ì½”ë“œ
# ==========================================

if __name__ == "__main__":
    print("ğŸ“Š ETF ì—…ë°ì´íŠ¸ ê´€ë¦¬ì í…ŒìŠ¤íŠ¸ (pykrx ì—°ë™ ë²„ì „)")
    print("=" * 60)
    
    # ì—…ë°ì´íŠ¸ ê´€ë¦¬ì ì´ˆê¸°í™”
    manager = ETFUpdateManager()
    
    # 1. ì‹œìŠ¤í…œ ìƒíƒœ ì²´í¬
    print("\nğŸ¥ ì‹œìŠ¤í…œ ìƒíƒœ ì²´í¬:")
    health = manager.quick_health_check()
    if health.get('status') != 'error':
        print(f"- ì´ ETF: {health['total_etfs']}ê°œ")
        print(f"- í™œì„± ETF: {health['active_etfs']}ê°œ")
        print(f"- ì—…ë°ì´íŠ¸ëœ ETF: {health['updated_etfs']}ê°œ")
        print(f"- ê°€ê²© ì •ë³´ ë³´ìœ : {health['price_available']}ê°œ")
        print(f"- 24ì‹œê°„ ë‚´ ì—…ë°ì´íŠ¸: {health['recent_updates_24h']}ê°œ")
        print(f"- ì‹œìŠ¤í…œ ìƒíƒœ: {health['status']} ({health['health_score']:.1f}%)")
        print(f"- ë°ì´í„° ì†ŒìŠ¤: {health['data_source']}")
        print(f"- ìµœì¢… ì˜ì—…ì¼: {health.get('last_business_day', 'Unknown')}")
        print(f"- pykrx ì‚¬ìš© ê°€ëŠ¥: {'ì˜ˆ' if health.get('pykrx_available') else 'ì•„ë‹ˆì˜¤'}")
    else:
        print(f"âŒ ìƒíƒœ ì²´í¬ ì‹¤íŒ¨: {health.get('error')}")
    
    # 2. ETF ìœ ë‹ˆë²„ìŠ¤ ìƒˆë¡œê³ ì¹¨ í…ŒìŠ¤íŠ¸
    print(f"\nğŸŒ ETF ìœ ë‹ˆë²„ìŠ¤ ìƒˆë¡œê³ ì¹¨ í…ŒìŠ¤íŠ¸:")
    if manager.refresh_etf_universe():
        print("âœ… ETF ìœ ë‹ˆë²„ìŠ¤ ìƒˆë¡œê³ ì¹¨ ì„±ê³µ")
    else:
        print("âŒ ETF ìœ ë‹ˆë²„ìŠ¤ ìƒˆë¡œê³ ì¹¨ ì‹¤íŒ¨")
    
    # 3. ì†Œê·œëª¨ ì—…ë°ì´íŠ¸ í…ŒìŠ¤íŠ¸
    print(f"\nâš¡ ì†Œê·œëª¨ ì—…ë°ì´íŠ¸ í…ŒìŠ¤íŠ¸ (3ê°œ ETF):")
    try:
        summary = manager.batch_update_all_etfs(max_etfs=3, delay_between_updates=0.5)
        if summary:
            print(f"\nğŸ“Š ìš”ì•½:")
            print(f"- ì†Œìš”ì‹œê°„: {summary.total_duration:.1f}ì´ˆ")
            print(f"- ì„±ê³µë¥ : {summary.success_rate:.1f}%")
            print(f"- ì„±ê³µ: {summary.successful_updates}ê°œ")
            print(f"- ì‹¤íŒ¨: {summary.failed_updates}ê°œ")
        else:
            print("âŒ ì—…ë°ì´íŠ¸ ì‹¤í–‰ ì‹¤íŒ¨")
    except Exception as e:
        print(f"âŒ í…ŒìŠ¤íŠ¸ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜: {e}")
    
    print(f"\nâœ… ETF ì—…ë°ì´íŠ¸ ê´€ë¦¬ì í…ŒìŠ¤íŠ¸ ì™„ë£Œ!")
    print(f"\nğŸ’¡ ë‹¤ìŒ ë‹¨ê³„:")
    print(f"   - ì „ì²´ ETF ì—…ë°ì´íŠ¸: manager.batch_update_all_etfs()")
    print(f"   - ìœ ë‹ˆë²„ìŠ¤ ê°•ì œ ìƒˆë¡œê³ ì¹¨: manager.batch_update_all_etfs(force_refresh_universe=True)")
    print(f"   - ëŒ€ì‹œë³´ë“œì—ì„œ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§")