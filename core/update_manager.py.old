# ==========================================
# core/update_manager.py - ETF ÏóÖÎç∞Ïù¥Ìä∏ Í¥ÄÎ¶¨Ïûê (pykrx Ïó∞Îèô Î≤ÑÏ†Ñ)
# ==========================================

import pandas as pd
import numpy as np
import sqlite3
import time
import json
import logging
import os
from datetime import datetime, timedelta
from typing import Dict, List, Tuple
from dataclasses import dataclass, asdict
import sys

# ÌîÑÎ°úÏ†ùÌä∏ Î™®Îìà import
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# MarketDataCollector import ÏãúÎèÑ
try:
    from data.market_data_collector import MarketDataCollector
    MARKET_DATA_AVAILABLE = True
    print("‚úÖ MarketDataCollector ÏÇ¨Ïö© Í∞ÄÎä•")
except ImportError as e:
    MARKET_DATA_AVAILABLE = False
    print(f"‚ö†Ô∏è MarketDataCollector import Ïã§Ìå®: {e}")
    
    # ÎçîÎØ∏ MarketDataCollector
    class MarketDataCollector:
        def __init__(self, db_path):
            self.db_path = db_path
            print(f"üîß ÎçîÎØ∏ MarketDataCollector ÏÇ¨Ïö©")
        
        def get_all_etf_list(self):
            return [
                {'code': '069500', 'name': 'KODEX 200', 'market_price': 28400},
                {'code': '360750', 'name': 'TIGER ÎØ∏Íµ≠S&P500', 'market_price': 15800},
                {'code': '114260', 'name': 'KODEX Íµ≠Í≥†Ï±Ñ10ÎÖÑ', 'market_price': 108500},
            ]
        
        def fetch_etf_price_data(self, code, period="1m"):
            import pandas as pd
            import numpy as np
            # ÎçîÎØ∏ Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
            dates = pd.date_range(end=datetime.now(), periods=30, freq='D')
            prices = np.random.normal(10000, 500, 30)
            return pd.DataFrame({
                'date': dates,
                'close': prices,
                'returns': np.random.normal(0, 0.02, 30)
            })
        
        def calculate_performance_metrics(self, price_data):
            return {'data_points': len(price_data), 'volatility': 15.0}
        
        def fetch_etf_info(self, code):
            return {'current_price': 10000 + hash(code) % 5000, 'volume': 50000}
        
        def get_market_status(self):
            return {
                'last_business_day': '20241220',
                'is_trading_hours': False,
                'pykrx_available': False
            }

try:
    from data.etf_universe import ETFUniverse
    ETF_UNIVERSE_AVAILABLE = True
except ImportError as e:
    ETF_UNIVERSE_AVAILABLE = False
    print(f"‚ö†Ô∏è ETFUniverse import Ïã§Ìå®: {e}")

@dataclass
class UpdateResult:
    """ÏóÖÎç∞Ïù¥Ìä∏ Í≤∞Í≥º Îç∞Ïù¥ÌÑ∞ ÌÅ¥ÎûòÏä§"""
    code: str
    name: str
    status: str  # 'success', 'failed', 'skipped'
    error_message: str = ""
    update_time: str = ""
    data_points: int = 0
    current_price: float = 0.0
    price_change: float = 0.0

@dataclass
class BatchUpdateSummary:
    """ÏùºÍ¥Ñ ÏóÖÎç∞Ïù¥Ìä∏ ÏöîÏïΩ"""
    start_time: str
    end_time: str
    total_etfs: int
    successful_updates: int
    failed_updates: int
    skipped_updates: int
    success_rate: float
    total_duration: float
    results: List[UpdateResult]
    errors: List[str]

class ETFUpdateManager:
    """ETF Îç∞Ïù¥ÌÑ∞ Ï†ÑÏ≤¥ ÏóÖÎç∞Ïù¥Ìä∏ Í¥ÄÎ¶¨Ïûê (pykrx Ïó∞Îèô Î≤ÑÏ†Ñ)"""
    
    def __init__(self, db_path: str = "etf_universe.db", log_level: str = "INFO"):
        self.db_path = db_path
        
        # Î°úÍπÖ ÏÑ§Ï†ï
        self.setup_logging(log_level)
        self.logger = logging.getLogger(__name__)
        
        # Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï¥àÍ∏∞Ìôî
        self._initialize_database()
        
        # MarketDataCollector Ï¥àÍ∏∞Ìôî
        self.collector = MarketDataCollector(db_path)
        
        # ÏóÖÎç∞Ïù¥Ìä∏ ÏÉÅÌÉú Ï∂îÏ†Å
        self.current_batch_id = None
        self.is_updating = False
        self.update_progress = 0
        self.update_status = "idle"
        
        # ÎßàÏßÄÎßâ Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞ Î°úÎìú ÏãúÎèÑ
        self.last_real_data_attempt = None
        self.use_real_data = MARKET_DATA_AVAILABLE
        
        self.logger.info("ETF ÏóÖÎç∞Ïù¥Ìä∏ Í¥ÄÎ¶¨Ïûê Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
    
    def setup_logging(self, level: str):
        """Î°úÍπÖ ÏÑ§Ï†ï"""
        logger = logging.getLogger()
        if not logger.handlers:
            log_format = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
            
            # ÏΩòÏÜî Ìï∏Îì§Îü¨
            console_handler = logging.StreamHandler(sys.stdout)
            console_handler.setFormatter(logging.Formatter(log_format))
            logger.addHandler(console_handler)
            
            # ÌååÏùº Ìï∏Îì§Îü¨ (ÏòµÏÖò)
            try:
                file_handler = logging.FileHandler('etf_updates.log', encoding='utf-8')
                file_handler.setFormatter(logging.Formatter(log_format))
                logger.addHandler(file_handler)
            except Exception as e:
                print(f"ÌååÏùº Î°úÍπÖ ÏÑ§Ï†ï Ïã§Ìå®: {e}")
        
        logger.setLevel(getattr(logging, level.upper()))
    
    def _initialize_database(self):
        """Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÌÖåÏù¥Î∏î Ï¥àÍ∏∞Ìôî"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            # ETF Ï†ïÎ≥¥ ÌÖåÏù¥Î∏î ÏÉùÏÑ± (pykrx Îç∞Ïù¥ÌÑ∞ Íµ¨Ï°∞Ïóê ÎßûÍ≤å)
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS etf_info (
                    code TEXT PRIMARY KEY,
                    name TEXT NOT NULL,
                    category TEXT,
                    subcategory TEXT,
                    asset_class TEXT,
                    region TEXT,
                    currency TEXT DEFAULT 'KRW',
                    expense_ratio REAL,
                    aum REAL DEFAULT 0,
                    market_price REAL DEFAULT 0,
                    nav REAL DEFAULT 0,
                    premium_discount REAL DEFAULT 0,
                    dividend_yield REAL DEFAULT 0,
                    tracking_error REAL DEFAULT 0,
                    benchmark TEXT,
                    fund_manager TEXT,
                    inception_date TEXT,
                    last_updated TEXT,
                    avg_volume INTEGER DEFAULT 0,
                    is_active BOOLEAN DEFAULT 1
                )
            ''')
            
            # ETF Í∞ÄÍ≤© ÌûàÏä§ÌÜ†Î¶¨ ÌÖåÏù¥Î∏î
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS etf_price_history (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    code TEXT,
                    date TEXT,
                    open_price REAL,
                    high_price REAL,
                    low_price REAL,
                    close_price REAL,
                    volume INTEGER,
                    returns REAL,
                    FOREIGN KEY (code) REFERENCES etf_info(code),
                    UNIQUE(code, date)
                )
            ''')
            
            # ÏóÖÎç∞Ïù¥Ìä∏ ÌûàÏä§ÌÜ†Î¶¨ ÌÖåÏù¥Î∏î
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS update_history (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    start_time TEXT,
                    end_time TEXT,
                    total_etfs INTEGER,
                    successful_updates INTEGER,
                    failed_updates INTEGER,
                    success_rate REAL,
                    total_duration REAL,
                    update_source TEXT,  -- 'pykrx' or 'dummy'
                    market_status TEXT,  -- JSON
                    summary_json TEXT
                )
            ''')
            
            conn.commit()
            conn.close()
            
            print(f"Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï¥àÍ∏∞Ìôî ÏôÑÎ£å: {self.db_path}")
            
        except Exception as e:
            print(f"Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï¥àÍ∏∞Ìôî Ïã§Ìå®: {e}")
    
    def refresh_etf_universe(self) -> bool:
        """ETF Ïú†ÎãàÎ≤ÑÏä§ ÏÉàÎ°úÍ≥†Ïπ® (pykrxÏóêÏÑú ÏµúÏã† Î™©Î°ù Í∞ÄÏ†∏Ïò§Í∏∞)"""
        try:
            self.logger.info("ETF Ïú†ÎãàÎ≤ÑÏä§ ÏÉàÎ°úÍ≥†Ïπ® ÏãúÏûë")
            
            # ÏãúÏû• ÏÉÅÌÉú ÌôïÏù∏
            market_status = self.collector.get_market_status()
            self.logger.info(f"ÏãúÏû• ÏÉÅÌÉú: {market_status}")
            
            # Ï†ÑÏ≤¥ ETF Î¶¨Ïä§Ìä∏ Í∞ÄÏ†∏Ïò§Í∏∞
            etf_list = self.collector.get_all_etf_list()
            
            if not etf_list:
                self.logger.warning("ETF Î¶¨Ïä§Ìä∏Í∞Ä ÎπÑÏñ¥ÏûàÏäµÎãàÎã§")
                return False
            
            # Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Ïóê Ï†ÄÏû•
            success = self._save_etf_universe_to_db(etf_list, market_status)
            
            if success:
                self.logger.info(f"ETF Ïú†ÎãàÎ≤ÑÏä§ ÏÉàÎ°úÍ≥†Ïπ® ÏôÑÎ£å: {len(etf_list)}Í∞ú")
                return True
            else:
                self.logger.error("ETF Ïú†ÎãàÎ≤ÑÏä§ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ï†ÄÏû• Ïã§Ìå®")
                return False
                
        except Exception as e:
            self.logger.error(f"ETF Ïú†ÎãàÎ≤ÑÏä§ ÏÉàÎ°úÍ≥†Ïπ® Ïã§Ìå®: {e}")
            return False
    
    def _save_etf_universe_to_db(self, etf_list: List[Dict], market_status: Dict) -> bool:
        """ETF Ïú†ÎãàÎ≤ÑÏä§Î•º Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Ïóê Ï†ÄÏû•"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            saved_count = 0
            
            for etf in etf_list:
                try:
                    cursor.execute('''
                        INSERT OR REPLACE INTO etf_info 
                        (code, name, category, market_price, aum, avg_volume, last_updated, is_active)
                        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
                    ''', (
                        etf['code'],
                        etf['name'],
                        etf.get('category', 'unknown'),
                        etf.get('market_price', 0),
                        etf.get('aum', 0),
                        etf.get('volume', 0),
                        etf.get('last_updated', datetime.now().isoformat()),
                        1  # is_active
                    ))
                    saved_count += 1
                    
                except Exception as e:
                    self.logger.warning(f"ETF {etf.get('code', 'unknown')} Ï†ÄÏû• Ïã§Ìå®: {e}")
                    continue
            
            # ÏãúÏû• ÏÉÅÌÉú Ï†ïÎ≥¥ÎèÑ Î≥ÑÎèÑ ÌÖåÏù¥Î∏îÏóê Ï†ÄÏû• (ÏÑ†ÌÉùÏ†Å)
            cursor.execute('''
                CREATE TABLE IF NOT EXISTS market_status_log (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    timestamp TEXT,
                    status_json TEXT
                )
            ''')
            
            cursor.execute('''
                INSERT INTO market_status_log (timestamp, status_json)
                VALUES (?, ?)
            ''', (datetime.now().isoformat(), json.dumps(market_status)))
            
            conn.commit()
            conn.close()
            
            self.logger.info(f"ETF Ïú†ÎãàÎ≤ÑÏä§ Ï†ÄÏû• ÏôÑÎ£å: {saved_count}Í∞ú")
            return True
            
        except Exception as e:
            self.logger.error(f"ETF Ïú†ÎãàÎ≤ÑÏä§ Ï†ÄÏû• Ïã§Ìå®: {e}")
            return False
    
    def get_etf_list_from_db(self) -> List[Tuple[str, str]]:
        """Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ÏóêÏÑú ETF Î¶¨Ïä§Ìä∏ Ï°∞Ìöå"""
        try:
            conn = sqlite3.connect(self.db_path)
            
            # ÌôúÏÑ± ETFÎßå Ï°∞Ìöå, AUMÏù¥ ÌÅ∞ ÏàúÏÑúÎ°ú
            query = '''
                SELECT code, name FROM etf_info 
                WHERE is_active = 1 
                ORDER BY aum DESC, market_price DESC
            '''
            df = pd.read_sql_query(query, conn)
            conn.close()
            
            if df.empty:
                self.logger.warning("DBÏóêÏÑú ETF Î¶¨Ïä§Ìä∏Í∞Ä ÎπÑÏñ¥ÏûàÏùå - Ïú†ÎãàÎ≤ÑÏä§ ÏÉàÎ°úÍ≥†Ïπ® ÏãúÎèÑ")
                
                # ETF Ïú†ÎãàÎ≤ÑÏä§ ÏÉàÎ°úÍ≥†Ïπ® ÏãúÎèÑ
                if self.refresh_etf_universe():
                    # Îã§Ïãú Ï°∞Ìöå
                    conn = sqlite3.connect(self.db_path)
                    df = pd.read_sql_query(query, conn)
                    conn.close()
            
            if not df.empty:
                etf_list = list(zip(df['code'], df['name']))
                self.logger.info(f"DBÏóêÏÑú ETF Î¶¨Ïä§Ìä∏ Ï°∞Ìöå: {len(etf_list)}Í∞ú")
                return etf_list
            else:
                # Í∏∞Î≥∏ ETF Î¶¨Ïä§Ìä∏ Î∞òÌôò
                return self._get_fallback_etf_list()
                
        except Exception as e:
            self.logger.error(f"DB ETF Î¶¨Ïä§Ìä∏ Ï°∞Ìöå Ïã§Ìå®: {e}")
            return self._get_fallback_etf_list()
    
    def _get_fallback_etf_list(self) -> List[Tuple[str, str]]:
        """Í∏∞Î≥∏ ETF Î¶¨Ïä§Ìä∏ (fallback)"""
        fallback_etfs = [
            ('069500', 'KODEX 200'),
            ('360750', 'TIGER ÎØ∏Íµ≠S&P500'),
            ('114260', 'KODEX Íµ≠Í≥†Ï±Ñ10ÎÖÑ'),
            ('133690', 'KODEX ÎÇòÏä§Îã•100'),
            ('195930', 'KODEX ÏÑ†ÏßÑÍµ≠MSCI'),
            ('229200', 'KODEX ÏΩîÏä§Îã•150'),
            ('305080', 'TIGER ÎØ∏Íµ≠Ï±Ñ10ÎÖÑ'),
            ('132030', 'KODEX Í≥®ÎìúÏÑ†Î¨º'),
            ('329200', 'KODEX Î¶¨Ï∏†'),
            ('305540', 'KODEX 2Ï∞®Ï†ÑÏßÄÏÇ∞ÏóÖ')
        ]
        
        self.logger.info(f"Í∏∞Î≥∏ ETF Î¶¨Ïä§Ìä∏ ÏÇ¨Ïö©: {len(fallback_etfs)}Í∞ú")
        return fallback_etfs
    
    def update_single_etf(self, code: str, name: str, timeout: int = 30) -> UpdateResult:
        """Í∞úÎ≥Ñ ETF ÏóÖÎç∞Ïù¥Ìä∏ (pykrx Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©)"""
        start_time = time.time()
        
        try:
            self.logger.info(f"{code} ({name}) ÏóÖÎç∞Ïù¥Ìä∏ ÏãúÏûë")
            
            # 1. Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞ ÏàòÏßë
            price_data = self.collector.fetch_etf_price_data(code, period="3m")
            
            if price_data.empty:
                return UpdateResult(
                    code=code,
                    name=name,
                    status="failed",
                    error_message="Í∞ÄÍ≤© Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå",
                    update_time=datetime.now().isoformat()
                )
            
            # 2. ÏÑ±Í≥º ÏßÄÌëú Í≥ÑÏÇ∞
            metrics = self.collector.calculate_performance_metrics(price_data)
            
            # 3. ETF Ï∂îÍ∞Ä Ï†ïÎ≥¥ ÏàòÏßë
            etf_info = self.collector.fetch_etf_info(code)
            
            # 4. Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏóÖÎç∞Ïù¥Ìä∏
            success = self._update_database_with_real_data(code, price_data, metrics, etf_info)
            
            if success:
                # Í∞ÄÍ≤© Î≥ÄÎèô Í≥ÑÏÇ∞
                if len(price_data) >= 2:
                    current_price = price_data['close'].iloc[-1]
                    prev_price = price_data['close'].iloc[-2]
                    price_change = ((current_price - prev_price) / prev_price) * 100
                else:
                    price_change = 0
                
                result = UpdateResult(
                    code=code,
                    name=name,
                    status="success",
                    update_time=datetime.now().isoformat(),
                    data_points=metrics.get('data_points', len(price_data)),
                    current_price=etf_info.get('current_price', 0),
                    price_change=round(price_change, 2)
                )
                
                duration = time.time() - start_time
                self.logger.info(f"{code} ÏóÖÎç∞Ïù¥Ìä∏ ÏÑ±Í≥µ ({duration:.1f}Ï¥à)")
                return result
            else:
                return UpdateResult(
                    code=code,
                    name=name,
                    status="failed",
                    error_message="Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®",
                    update_time=datetime.now().isoformat()
                )
                
        except Exception as e:
            error_msg = str(e)[:100]
            self.logger.error(f"{code} ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®: {error_msg}")
            
            return UpdateResult(
                code=code,
                name=name,
                status="failed",
                error_message=error_msg,
                update_time=datetime.now().isoformat()
            )
    
    def _update_database_with_real_data(self, code: str, price_data: pd.DataFrame, 
                                       metrics: dict, etf_info: dict) -> bool:
        """Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞Î°ú Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏóÖÎç∞Ïù¥Ìä∏"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            current_time = datetime.now().isoformat()
            
            # ETF Í∏∞Î≥∏ Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏
            cursor.execute('''
                UPDATE etf_info 
                SET market_price = ?, nav = ?, avg_volume = ?, last_updated = ?
                WHERE code = ?
            ''', (
                etf_info.get('current_price', 0),
                etf_info.get('nav', 0),
                etf_info.get('volume', 0),
                current_time,
                code
            ))
            
            # Í∞ÄÍ≤© ÌûàÏä§ÌÜ†Î¶¨ Ï†ÄÏû• (ÏµúÍ∑º Îç∞Ïù¥ÌÑ∞Îßå)
            if not price_data.empty:
                # ÏµúÍ∑º 5Ïùº Îç∞Ïù¥ÌÑ∞Îßå Ï†ÄÏû•
                recent_data = price_data.tail(5)
                
                for _, row in recent_data.iterrows():
                    try:
                        date_str = row['date'].strftime('%Y-%m-%d') if hasattr(row['date'], 'strftime') else str(row['date'])[:10]
                        
                        cursor.execute('''
                            INSERT OR REPLACE INTO etf_price_history
                            (code, date, close_price, volume, returns)
                            VALUES (?, ?, ?, ?, ?)
                        ''', (
                            code,
                            date_str,
                            row.get('close', 0),
                            row.get('volume', 0),
                            row.get('returns', 0)
                        ))
                    except Exception as e:
                        self.logger.debug(f"Í∞ÄÍ≤© ÌûàÏä§ÌÜ†Î¶¨ Ï†ÄÏû• Ïã§Ìå®: {e}")
                        continue
            
            conn.commit()
            conn.close()
            
            self.logger.debug(f"ETF {code} Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å")
            return True
            
        except Exception as e:
            self.logger.error(f"ETF {code} Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®: {e}")
            return False
    
    def batch_update_all_etfs(self, 
                             max_etfs: int = None, 
                             delay_between_updates: float = 1.0,
                             max_failures: int = 10,
                             force_refresh_universe: bool = False) -> BatchUpdateSummary:
        """Ï†ÑÏ≤¥ ETF ÏùºÍ¥Ñ ÏóÖÎç∞Ïù¥Ìä∏ (pykrx Îç∞Ïù¥ÌÑ∞ ÏÇ¨Ïö©)"""
        
        if self.is_updating:
            self.logger.warning("Ïù¥ÎØ∏ ÏóÖÎç∞Ïù¥Ìä∏Í∞Ä ÏßÑÌñâ Ï§ëÏûÖÎãàÎã§")
            return None
        
        self.is_updating = True
        self.update_status = "running"
        start_time = datetime.now()
        
        try:
            # ÏãúÏû• ÏÉÅÌÉú ÌôïÏù∏
            market_status = self.collector.get_market_status()
            self.logger.info(f"ÏãúÏû• ÏÉÅÌÉú: {market_status}")
            
            # ETF Ïú†ÎãàÎ≤ÑÏä§ ÏÉàÎ°úÍ≥†Ïπ® (ÏòµÏÖò)
            if force_refresh_universe or self._should_refresh_universe():
                self.logger.info("ETF Ïú†ÎãàÎ≤ÑÏä§ ÏÉàÎ°úÍ≥†Ïπ® Ïã§Ìñâ")
                self.refresh_etf_universe()
            
            # ETF Î¶¨Ïä§Ìä∏ Ï°∞Ìöå
            etf_list = self.get_etf_list_from_db()
            
            if max_etfs:
                etf_list = etf_list[:max_etfs]
            
            total_etfs = len(etf_list)
            self.logger.info(f"ÏùºÍ¥Ñ ÏóÖÎç∞Ïù¥Ìä∏ ÏãúÏûë: {total_etfs}Í∞ú ETF")
            
            print(f"\n{'='*60}")
            print(f"üìä ETF ÏùºÍ¥Ñ ÏóÖÎç∞Ïù¥Ìä∏ ÏãúÏûë (pykrx Ïó∞Îèô)")
            print(f"ÎåÄÏÉÅ ETF: {total_etfs}Í∞ú")
            print(f"ÏóÖÎç∞Ïù¥Ìä∏ Í∞ÑÍ≤©: {delay_between_updates}Ï¥à")
            print(f"ÏµúÎåÄ Ïã§Ìå® ÌóàÏö©: {max_failures}Í∞ú")
            print(f"Îç∞Ïù¥ÌÑ∞ ÏÜåÏä§: {'pykrx (Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞)' if MARKET_DATA_AVAILABLE else 'Dummy (ÏãúÎÆ¨Î†àÏù¥ÏÖò)'}")
            print(f"ÏµúÏ¢Ö ÏòÅÏóÖÏùº: {market_status.get('last_business_day', 'Unknown')}")
            print(f"{'='*60}\n")
            
            # ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìñâ
            results = []
            successful_count = 0
            failed_count = 0
            consecutive_failures = 0
            
            for i, (code, name) in enumerate(etf_list):
                self.update_progress = (i / total_etfs) * 100
                
                print(f"[{i+1:3d}/{total_etfs}] {code} ({name}) Ï≤òÎ¶¨ Ï§ë...")
                
                # Í∞úÎ≥Ñ ETF ÏóÖÎç∞Ïù¥Ìä∏
                result = self.update_single_etf(code, name)
                results.append(result)
                
                if result.status == "success":
                    successful_count += 1
                    consecutive_failures = 0
                    price_info = f"{result.current_price:,.0f}Ïõê" if result.current_price > 0 else "Í∞ÄÍ≤©Ï†ïÎ≥¥ÏóÜÏùå"
                    change_info = f"({result.price_change:+.2f}%)" if result.price_change != 0 else ""
                    print(f"   ‚úÖ ÏÑ±Í≥µ: {price_info} {change_info}")
                else:
                    failed_count += 1
                    consecutive_failures += 1
                    print(f"   ‚ùå Ïã§Ìå®: {result.error_message}")
                
                # Ïó∞ÏÜç Ïã§Ìå® Ï≤¥ÌÅ¨
                if consecutive_failures >= max_failures:
                    self.logger.error(f"Ïó∞ÏÜç {max_failures}Ìöå Ïã§Ìå®Î°ú ÏóÖÎç∞Ïù¥Ìä∏ Ï§ëÎã®")
                    break
                
                # ÏßÑÌñâÎ•† ÌëúÏãú
                if (i + 1) % 5 == 0 or (i + 1) == total_etfs:
                    success_rate = (successful_count / (i + 1)) * 100
                    print(f"   üìä ÏßÑÌñâÎ•†: {i+1}/{total_etfs} ({success_rate:.1f}% ÏÑ±Í≥µ)")
                
                # ÏßÄÏó∞
                if i < len(etf_list) - 1:
                    time.sleep(delay_between_updates)
            
            # ÏöîÏïΩ ÏÉùÏÑ±
            end_time = datetime.now()
            duration = (end_time - start_time).total_seconds()
            success_rate = (successful_count / len(results)) * 100 if results else 0
            
            summary = BatchUpdateSummary(
                start_time=start_time.isoformat(),
                end_time=end_time.isoformat(),
                total_etfs=len(results),
                successful_updates=successful_count,
                failed_updates=failed_count,
                skipped_updates=0,
                success_rate=round(success_rate, 1),
                total_duration=round(duration, 1),
                results=results,
                errors=[r.error_message for r in results if r.status == "failed" and r.error_message]
            )
            
            # Í≤∞Í≥º Ï∂úÎ†•
            print(f"\n{'='*60}")
            print(f"üìà ÏùºÍ¥Ñ ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å!")
            print(f"ÏÜåÏöî ÏãúÍ∞Ñ: {duration/60:.1f}Î∂Ñ")
            print(f"ÏÑ±Í≥µ: {successful_count}Í∞ú")
            print(f"Ïã§Ìå®: {failed_count}Í∞ú")
            print(f"ÏÑ±Í≥µÎ•†: {success_rate:.1f}%")
            print(f"Îç∞Ïù¥ÌÑ∞ ÏÜåÏä§: {'pykrx (Ïã§Ï†ú)' if MARKET_DATA_AVAILABLE else 'Dummy (ÏãúÎÆ¨Î†àÏù¥ÏÖò)'}")
            print(f"{'='*60}")
            
            # Í≤∞Í≥º Ï†ÄÏû•
            self.save_update_summary(summary, market_status)
            
            self.logger.info(f"ÏùºÍ¥Ñ ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å: {success_rate:.1f}% ÏÑ±Í≥µ")
            return summary
            
        except Exception as e:
            self.logger.error(f"ÏùºÍ¥Ñ ÏóÖÎç∞Ïù¥Ìä∏ Ï§ë Ïò§Î•ò: {e}")
            raise
        finally:
            self.is_updating = False
            self.update_status = "idle"
            self.update_progress = 0
    
    def _should_refresh_universe(self) -> bool:
        """ETF Ïú†ÎãàÎ≤ÑÏä§ ÏÉàÎ°úÍ≥†Ïπ®Ïù¥ ÌïÑÏöîÌïúÏßÄ ÌôïÏù∏"""
        try:
            conn = sqlite3.connect(self.db_path)
            
            # ÎßàÏßÄÎßâ ÏóÖÎç∞Ïù¥Ìä∏ ÏãúÍ∞Ñ ÌôïÏù∏
            cursor = conn.execute('''
                SELECT MAX(last_updated) as last_update 
                FROM etf_info 
                WHERE last_updated IS NOT NULL
            ''')
            
            result = cursor.fetchone()
            conn.close()
            
            if not result or not result[0]:
                return True  # Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏúºÎ©¥ ÏÉàÎ°úÍ≥†Ïπ®
            
            last_update = datetime.fromisoformat(result[0])
            hours_since_update = (datetime.now() - last_update).total_seconds() / 3600
            
            # 24ÏãúÍ∞Ñ Ïù¥ÏÉÅ ÏßÄÎÇ¨ÏúºÎ©¥ ÏÉàÎ°úÍ≥†Ïπ®
            return hours_since_update >= 24
            
        except Exception as e:
            self.logger.warning(f"Ïú†ÎãàÎ≤ÑÏä§ ÏÉàÎ°úÍ≥†Ïπ® ÌïÑÏöîÏÑ± ÌôïÏù∏ Ïã§Ìå®: {e}")
            return False
    
    def save_update_summary(self, summary: BatchUpdateSummary, market_status: Dict = None):
        """ÏóÖÎç∞Ïù¥Ìä∏ ÏöîÏïΩ Ï†ÄÏû• (ÏãúÏû• ÏÉÅÌÉú Ìè¨Ìï®)"""
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            # ÏóÖÎç∞Ïù¥Ìä∏ ÏÜåÏä§ Í≤∞Ï†ï
            update_source = 'pykrx' if MARKET_DATA_AVAILABLE else 'dummy'
            
            cursor.execute('''
                INSERT INTO update_history 
                (start_time, end_time, total_etfs, successful_updates, failed_updates, 
                 success_rate, total_duration, update_source, market_status, summary_json)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            ''', (
                summary.start_time,
                summary.end_time,
                summary.total_etfs,
                summary.successful_updates,
                summary.failed_updates,
                summary.success_rate,
                summary.total_duration,
                update_source,
                json.dumps(market_status) if market_status else None,
                json.dumps(asdict(summary), ensure_ascii=False, indent=2)
            ))
            
            conn.commit()
            conn.close()
            
            self.logger.info("ÏóÖÎç∞Ïù¥Ìä∏ ÏöîÏïΩ Ï†ÄÏû• ÏôÑÎ£å")
            
        except Exception as e:
            self.logger.error(f"ÏóÖÎç∞Ïù¥Ìä∏ ÏöîÏïΩ Ï†ÄÏû• Ïã§Ìå®: {e}")
    
    def get_update_history(self, limit: int = 10) -> List[Dict]:
        """ÏóÖÎç∞Ïù¥Ìä∏ ÌûàÏä§ÌÜ†Î¶¨ Ï°∞Ìöå"""
        try:
            conn = sqlite3.connect(self.db_path)
            query = '''
                SELECT * FROM update_history 
                ORDER BY start_time DESC 
                LIMIT ?
            '''
            df = pd.read_sql_query(query, conn, params=(limit,))
            conn.close()
            
            return df.to_dict('records')
            
        except Exception as e:
            self.logger.error(f"ÏóÖÎç∞Ïù¥Ìä∏ ÌûàÏä§ÌÜ†Î¶¨ Ï°∞Ìöå Ïã§Ìå®: {e}")
            return []
    
    def get_current_status(self) -> Dict:
        """ÌòÑÏû¨ ÏóÖÎç∞Ïù¥Ìä∏ ÏÉÅÌÉú Ï°∞Ìöå"""
        market_status = self.collector.get_market_status()
        
        return {
            'is_updating': self.is_updating,
            'status': self.update_status,
            'progress': self.update_progress,
            'last_update': self.get_last_update_time(),
            'data_source': 'pykrx' if MARKET_DATA_AVAILABLE else 'dummy',
            'market_status': market_status
        }
    
    def get_last_update_time(self) -> str:
        """ÎßàÏßÄÎßâ ÏóÖÎç∞Ïù¥Ìä∏ ÏãúÍ∞Ñ Ï°∞Ìöå"""
        try:
            conn = sqlite3.connect(self.db_path)
            query = "SELECT MAX(last_updated) as last_update FROM etf_info"
            result = pd.read_sql_query(query, conn).iloc[0]['last_update']
            conn.close()
            return result or "ÏóÖÎç∞Ïù¥Ìä∏ Í∏∞Î°ù ÏóÜÏùå"
        except:
            return "ÏóÖÎç∞Ïù¥Ìä∏ Í∏∞Î°ù ÏóÜÏùå"
    
    def quick_health_check(self) -> Dict:
        """ÏãúÏä§ÌÖú ÏÉÅÌÉú Ï≤¥ÌÅ¨ (pykrx Ïó∞Îèô ÏÉÅÌÉú Ìè¨Ìï®)"""
        try:
            conn = sqlite3.connect(self.db_path)
            
            # Í∏∞Î≥∏ ÌÜµÍ≥Ñ
            stats = pd.read_sql_query('''
                SELECT 
                    COUNT(*) as total_etfs,
                    COUNT(CASE WHEN last_updated IS NOT NULL THEN 1 END) as updated_etfs,
                    COUNT(CASE WHEN market_price > 0 THEN 1 END) as price_available,
                    COUNT(CASE WHEN is_active = 1 THEN 1 END) as active_etfs
                FROM etf_info
            ''', conn).iloc[0]
            
            # ÏµúÍ∑º ÏóÖÎç∞Ïù¥Ìä∏
            recent_updates = pd.read_sql_query('''
                SELECT COUNT(*) as recent_count
                FROM etf_info 
                WHERE last_updated > datetime('now', '-1 day')
            ''', conn).iloc[0]['recent_count']
            
            conn.close()
            
            health_score = (stats['updated_etfs'] / stats['total_etfs']) * 100 if stats['total_etfs'] > 0 else 0
            
            # ÏãúÏû• ÏÉÅÌÉú Ï†ïÎ≥¥ Ï∂îÍ∞Ä
            market_status = self.collector.get_market_status()
            
            return {
                'total_etfs': int(stats['total_etfs']),
                'updated_etfs': int(stats['updated_etfs']),
                'price_available': int(stats['price_available']),
                'active_etfs': int(stats['active_etfs']),
                'recent_updates_24h': int(recent_updates),
                'health_score': round(health_score, 1),
                'status': 'healthy' if health_score > 80 else 'warning' if health_score > 50 else 'critical',
                'data_source': 'pykrx' if MARKET_DATA_AVAILABLE else 'dummy',
                'last_business_day': market_status.get('last_business_day'),
                'is_trading_hours': market_status.get('is_trading_hours', False),
                'pykrx_available': market_status.get('pykrx_available', False)
            }
            
        except Exception as e:
            self.logger.error(f"ÏãúÏä§ÌÖú ÏÉÅÌÉú Ï≤¥ÌÅ¨ Ïã§Ìå®: {e}")
            return {'status': 'error', 'error': str(e), 'health_score': 0.0}


# ==========================================
# Ïã§Ìñâ ÏòàÏ†ú Î∞è ÌÖåÏä§Ìä∏ ÏΩîÎìú
# ==========================================

if __name__ == "__main__":
    print("üìä ETF ÏóÖÎç∞Ïù¥Ìä∏ Í¥ÄÎ¶¨Ïûê ÌÖåÏä§Ìä∏ (pykrx Ïó∞Îèô Î≤ÑÏ†Ñ)")
    print("=" * 60)
    
    # ÏóÖÎç∞Ïù¥Ìä∏ Í¥ÄÎ¶¨Ïûê Ï¥àÍ∏∞Ìôî
    manager = ETFUpdateManager()
    
    # 1. ÏãúÏä§ÌÖú ÏÉÅÌÉú Ï≤¥ÌÅ¨
    print("\nüè• ÏãúÏä§ÌÖú ÏÉÅÌÉú Ï≤¥ÌÅ¨:")
    health = manager.quick_health_check()
    if health.get('status') != 'error':
        print(f"- Ï¥ù ETF: {health['total_etfs']}Í∞ú")
        print(f"- ÌôúÏÑ± ETF: {health['active_etfs']}Í∞ú")
        print(f"- ÏóÖÎç∞Ïù¥Ìä∏Îêú ETF: {health['updated_etfs']}Í∞ú")
        print(f"- Í∞ÄÍ≤© Ï†ïÎ≥¥ Î≥¥Ïú†: {health['price_available']}Í∞ú")
        print(f"- 24ÏãúÍ∞Ñ ÎÇ¥ ÏóÖÎç∞Ïù¥Ìä∏: {health['recent_updates_24h']}Í∞ú")
        print(f"- ÏãúÏä§ÌÖú ÏÉÅÌÉú: {health['status']} ({health['health_score']:.1f}%)")
        print(f"- Îç∞Ïù¥ÌÑ∞ ÏÜåÏä§: {health['data_source']}")
        print(f"- ÏµúÏ¢Ö ÏòÅÏóÖÏùº: {health.get('last_business_day', 'Unknown')}")
        print(f"- pykrx ÏÇ¨Ïö© Í∞ÄÎä•: {'Ïòà' if health.get('pykrx_available') else 'ÏïÑÎãàÏò§'}")
    else:
        print(f"‚ùå ÏÉÅÌÉú Ï≤¥ÌÅ¨ Ïã§Ìå®: {health.get('error')}")
    
    # 2. ETF Ïú†ÎãàÎ≤ÑÏä§ ÏÉàÎ°úÍ≥†Ïπ® ÌÖåÏä§Ìä∏
    print(f"\nüåê ETF Ïú†ÎãàÎ≤ÑÏä§ ÏÉàÎ°úÍ≥†Ïπ® ÌÖåÏä§Ìä∏:")
    if manager.refresh_etf_universe():
        print("‚úÖ ETF Ïú†ÎãàÎ≤ÑÏä§ ÏÉàÎ°úÍ≥†Ïπ® ÏÑ±Í≥µ")
    else:
        print("‚ùå ETF Ïú†ÎãàÎ≤ÑÏä§ ÏÉàÎ°úÍ≥†Ïπ® Ïã§Ìå®")
    
    # 3. ÏÜåÍ∑úÎ™® ÏóÖÎç∞Ïù¥Ìä∏ ÌÖåÏä§Ìä∏
    print(f"\n‚ö° ÏÜåÍ∑úÎ™® ÏóÖÎç∞Ïù¥Ìä∏ ÌÖåÏä§Ìä∏ (3Í∞ú ETF):")
    try:
        summary = manager.batch_update_all_etfs(max_etfs=3, delay_between_updates=0.5)
        if summary:
            print(f"\nüìä ÏöîÏïΩ:")
            print(f"- ÏÜåÏöîÏãúÍ∞Ñ: {summary.total_duration:.1f}Ï¥à")
            print(f"- ÏÑ±Í≥µÎ•†: {summary.success_rate:.1f}%")
            print(f"- ÏÑ±Í≥µ: {summary.successful_updates}Í∞ú")
            print(f"- Ïã§Ìå®: {summary.failed_updates}Í∞ú")
        else:
            print("‚ùå ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìñâ Ïã§Ìå®")
    except Exception as e:
        print(f"‚ùå ÌÖåÏä§Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏ Ïò§Î•ò: {e}")
    
    print(f"\n‚úÖ ETF ÏóÖÎç∞Ïù¥Ìä∏ Í¥ÄÎ¶¨Ïûê ÌÖåÏä§Ìä∏ ÏôÑÎ£å!")
    print(f"\nüí° Îã§Ïùå Îã®Í≥Ñ:")
    print(f"   - Ï†ÑÏ≤¥ ETF ÏóÖÎç∞Ïù¥Ìä∏: manager.batch_update_all_etfs()")
    print(f"   - Ïú†ÎãàÎ≤ÑÏä§ Í∞ïÏ†ú ÏÉàÎ°úÍ≥†Ïπ®: manager.batch_update_all_etfs(force_refresh_universe=True)")
    print(f"   - ÎåÄÏãúÎ≥¥ÎìúÏóêÏÑú Ïã§ÏãúÍ∞Ñ Î™®ÎãàÌÑ∞ÎßÅ")