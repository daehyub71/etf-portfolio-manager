# ==========================================
# dashboard.py - ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ
# ==========================================

import pandas as pd
import numpy as np
import sqlite3
import json
import time
from datetime import datetime, timedelta
import sys
import os

# Streamlit import ì‹œë„
try:
    import streamlit as st
    import plotly.graph_objects as go
    import plotly.express as px
    from plotly.subplots import make_subplots
    STREAMLIT_AVAILABLE = True
    print("âœ… Streamlit ì‚¬ìš© ê°€ëŠ¥")
except ImportError:
    STREAMLIT_AVAILABLE = False
    print("âš ï¸ Streamlit ì—†ìŒ - CLI ëª¨ë“œë¡œ ì‹¤í–‰")
    print("pip install streamlit plotly í›„ ì›¹ ëŒ€ì‹œë³´ë“œ ì‚¬ìš© ê°€ëŠ¥")

# í”„ë¡œì íŠ¸ ëª¨ë“ˆ import
sys.path.append(os.path.dirname(os.path.abspath(__file__)))
from update_manager import ETFUpdateManager
from scheduler import ETFScheduler
from data.etf_analyzer import ETFAnalyzer
from data.etf_screener import ETFScreener

class ETFDashboard:
    """ETF ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ"""
    
    def __init__(self, db_path: str = "etf_universe.db"):
        self.db_path = db_path
        self.update_manager = ETFUpdateManager(db_path)
        self.analyzer = ETFAnalyzer(db_path)
        self.screener = ETFScreener(db_path)
        
        # ìŠ¤ì¼€ì¤„ëŸ¬ëŠ” ì„ íƒì ìœ¼ë¡œ ì´ˆê¸°í™”
        try:
            self.scheduler = ETFScheduler()
        except Exception as e:
            print(f"âš ï¸ ìŠ¤ì¼€ì¤„ëŸ¬ ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
            self.scheduler = None
    
    def get_market_overview(self) -> dict:
        """ì‹œìž¥ ì „ì²´ í˜„í™©"""
        try:
            conn = sqlite3.connect(self.db_path)
            
            # ê¸°ë³¸ í†µê³„
            overview = pd.read_sql_query('''
                SELECT 
                    COUNT(*) as total_etfs,
                    SUM(aum) as total_aum,
                    AVG(expense_ratio) as avg_expense_ratio,
                    COUNT(CASE WHEN market_price > 0 THEN 1 END) as price_available,
                    COUNT(CASE WHEN last_updated > datetime('now', '-1 day') THEN 1 END) as updated_24h
                FROM etf_info
            ''', conn).iloc[0]
            
            # ì¹´í…Œê³ ë¦¬ë³„ ë¶„í¬
            category_stats = pd.read_sql_query('''
                SELECT 
                    category,
                    COUNT(*) as count,
                    SUM(aum) as total_aum,
                    AVG(expense_ratio) as avg_expense
                FROM etf_info
                GROUP BY category
                ORDER BY total_aum DESC
            ''', conn)
            
            # ì„±ê³¼ ì§€í‘œ
            performance = pd.read_sql_query('''
                SELECT 
                    AVG(dividend_yield) as avg_dividend,
                    AVG(tracking_error) as avg_tracking_error,
                    COUNT(CASE WHEN dividend_yield > 3 THEN 1 END) as high_dividend_count
                FROM etf_info
                WHERE dividend_yield > 0
            ''', conn).iloc[0]
            
            conn.close()
            
            return {
                'overview': overview.to_dict(),
                'category_stats': category_stats.to_dict('records'),
                'performance': performance.to_dict(),
                'last_update': datetime.now().isoformat()
            }
            
        except Exception as e:
            print(f"âŒ ì‹œìž¥ í˜„í™© ì¡°íšŒ ì‹¤íŒ¨: {e}")
            return {}
    
    def get_top_etfs(self, metric: str = 'aum', limit: int = 10) -> pd.DataFrame:
        """ìƒìœ„ ETF ì¡°íšŒ"""
        try:
            conn = sqlite3.connect(self.db_path)
            
            order_direction = "DESC" if metric in ['aum', 'dividend_yield', 'market_price'] else "ASC"
            
            query = f'''
                SELECT 
                    name, code, category, aum, expense_ratio, 
                    dividend_yield, market_price, last_updated
                FROM etf_info
                WHERE {metric} > 0
                ORDER BY {metric} {order_direction}
                LIMIT ?
            '''
            
            df = pd.read_sql_query(query, conn, params=(limit,))
            conn.close()
            
            return df
            
        except Exception as e:
            print(f"âŒ ìƒìœ„ ETF ì¡°íšŒ ì‹¤íŒ¨: {e}")
            return pd.DataFrame()
    
    def get_update_status(self) -> dict:
        """ì—…ë°ì´íŠ¸ ìƒíƒœ ì¡°íšŒ"""
        try:
            # í˜„ìž¬ ì—…ë°ì´íŠ¸ ìƒíƒœ
            current_status = self.update_manager.get_current_status()
            
            # ì‹œìŠ¤í…œ ê±´ê°• ìƒíƒœ
            health = self.update_manager.quick_health_check()
            
            # ìµœê·¼ ì—…ë°ì´íŠ¸ ížˆìŠ¤í† ë¦¬
            history = self.update_manager.get_update_history(5)
            
            # ìŠ¤ì¼€ì¤„ëŸ¬ ìƒíƒœ
            scheduler_status = {}
            if self.scheduler:
                scheduler_status = self.scheduler.get_status()
            
            return {
                'current_status': current_status,
                'health': health,
                'recent_history': history,
                'scheduler': scheduler_status
            }
            
        except Exception as e:
            print(f"âŒ ì—…ë°ì´íŠ¸ ìƒíƒœ ì¡°íšŒ ì‹¤íŒ¨: {e}")
            return {}
    
    def run_streamlit_dashboard(self):
        """Streamlit ì›¹ ëŒ€ì‹œë³´ë“œ ì‹¤í–‰"""
        if not STREAMLIT_AVAILABLE:
            print("âŒ Streamlitì´ ì„¤ì¹˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")
            return
        
        st.set_page_config(
            page_title="ETF ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ",
            page_icon="ðŸ“Š",
            layout="wide",
            initial_sidebar_state="expanded"
        )
        
        st.title("ðŸ“Š ETF ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ")
        st.markdown("---")
        
        # ì‚¬ì´ë“œë°” - ì œì–´íŒ
        st.sidebar.title("ðŸŽ›ï¸ ì œì–´íŒ")
        
        # ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ í† ê¸€
        auto_refresh = st.sidebar.checkbox("ðŸ”„ ìžë™ ìƒˆë¡œê³ ì¹¨ (30ì´ˆ)", value=True)
        
        if auto_refresh:
            time.sleep(1)
            st.rerun()
        
        # ìˆ˜ë™ ìƒˆë¡œê³ ì¹¨
        if st.sidebar.button("ðŸ”„ ìˆ˜ë™ ìƒˆë¡œê³ ì¹¨"):
            st.rerun()
        
        # ë©”ì¸ íƒ­ êµ¬ì„±
        tab1, tab2, tab3, tab4, tab5 = st.tabs([
            "ðŸ  ì‹œìž¥ í˜„í™©", "ðŸ“ˆ ì—…ë°ì´íŠ¸ ìƒíƒœ", "ðŸ” ETF ê²€ìƒ‰", "ðŸ“Š ì„±ê³¼ ë¶„ì„", "âš™ï¸ ì‹œìŠ¤í…œ ê´€ë¦¬"
        ])
        
        with tab1:
            self._render_market_overview()
        
        with tab2:
            self._render_update_status()
        
        with tab3:
            self._render_etf_search()
        
        with tab4:
            self._render_performance_analysis()
        
        with tab5:
            self._render_system_management()
    
    def _render_market_overview(self):
        """ì‹œìž¥ í˜„í™© íƒ­ ë Œë”ë§"""
        st.header("ðŸ  ETF ì‹œìž¥ í˜„í™©")
        
        # ì‹œìž¥ ë°ì´í„° ë¡œë“œ
        market_data = self.get_market_overview()
        
        if not market_data:
            st.error("âŒ ì‹œìž¥ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
            return
        
        overview = market_data['overview']
        
        # ì£¼ìš” ì§€í‘œ ì¹´ë“œ
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric(
                "ì´ ETF ê°œìˆ˜",
                f"{overview['total_etfs']:,}ê°œ",
                delta=None
            )
        
        with col2:
            st.metric(
                "ì´ ìˆœìžì‚°",
                f"{overview['total_aum']:,.0f}ì–µì›",
                delta=None
            )
        
        with col3:
            st.metric(
                "í‰ê·  ìš´ìš©ë³´ìˆ˜",
                f"{overview['avg_expense_ratio']:.3f}%",
                delta=None
            )
        
        with col4:
            st.metric(
                "24ì‹œê°„ ë‚´ ì—…ë°ì´íŠ¸",
                f"{overview['updated_24h']}ê°œ",
                delta=f"{overview['updated_24h'] - overview['total_etfs']}ê°œ" if overview['total_etfs'] > 0 else None
            )
        
        # ì¹´í…Œê³ ë¦¬ë³„ ë¶„í¬
        st.subheader("ðŸ“Š ì¹´í…Œê³ ë¦¬ë³„ ë¶„í¬")
        
        if market_data['category_stats']:
            category_df = pd.DataFrame(market_data['category_stats'])
            
            col1, col2 = st.columns(2)
            
            with col1:
                # íŒŒì´ ì°¨íŠ¸
                fig_pie = px.pie(
                    category_df, 
                    values='total_aum', 
                    names='category',
                    title="ì¹´í…Œê³ ë¦¬ë³„ ìˆœìžì‚° ë¹„ì¤‘"
                )
                st.plotly_chart(fig_pie, use_container_width=True)
            
            with col2:
                # ë°” ì°¨íŠ¸
                fig_bar = px.bar(
                    category_df, 
                    x='category', 
                    y='count',
                    title="ì¹´í…Œê³ ë¦¬ë³„ ETF ê°œìˆ˜"
                )
                st.plotly_chart(fig_bar, use_container_width=True)
        
        # ìƒìœ„ ETF ë¦¬ìŠ¤íŠ¸
        st.subheader("ðŸ† ìƒìœ„ ETF (ìˆœìžì‚° ê¸°ì¤€)")
        top_etfs = self.get_top_etfs('aum', 10)
        
        if not top_etfs.empty:
            # í‘œì‹œìš© ë°ì´í„° ê°€ê³µ
            display_df = top_etfs.copy()
            display_df['ìˆœìžì‚°'] = display_df['aum'].apply(lambda x: f"{x:,.0f}ì–µì›")
            display_df['ìš´ìš©ë³´ìˆ˜'] = display_df['expense_ratio'].apply(lambda x: f"{x:.3f}%")
            display_df['ë°°ë‹¹ìˆ˜ìµë¥ '] = display_df['dividend_yield'].apply(lambda x: f"{x:.2f}%")
            
            st.dataframe(
                display_df[['name', 'code', 'category', 'ìˆœìžì‚°', 'ìš´ìš©ë³´ìˆ˜', 'ë°°ë‹¹ìˆ˜ìµë¥ ']],
                use_container_width=True
            )
    
    def _render_update_status(self):
        """ì—…ë°ì´íŠ¸ ìƒíƒœ íƒ­ ë Œë”ë§"""
        st.header("ðŸ“ˆ ì—…ë°ì´íŠ¸ ìƒíƒœ ëª¨ë‹ˆí„°ë§")
        
        # ì—…ë°ì´íŠ¸ ìƒíƒœ ë¡œë“œ
        status_data = self.get_update_status()
        
        if not status_data:
            st.error("âŒ ì—…ë°ì´íŠ¸ ìƒíƒœ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
            return
        
        # í˜„ìž¬ ìƒíƒœ
        current = status_data.get('current_status', {})
        health = status_data.get('health', {})
        
        # ìƒíƒœ í‘œì‹œ
        col1, col2, col3 = st.columns(3)
        
        with col1:
            if current.get('is_updating'):
                st.error(f"ðŸ”„ ì—…ë°ì´íŠ¸ ì§„í–‰ ì¤‘ ({current.get('progress', 0):.1f}%)")
            else:
                st.success("âœ… ì—…ë°ì´íŠ¸ ëŒ€ê¸° ì¤‘")
        
        with col2:
            health_score = health.get('health_score', 0)
            if health_score > 80:
                st.success(f"ðŸ’š ì‹œìŠ¤í…œ ê±´ê°•: {health_score:.1f}%")
            elif health_score > 50:
                st.warning(f"ðŸ’› ì‹œìŠ¤í…œ ì£¼ì˜: {health_score:.1f}%")
            else:
                st.error(f"â¤ï¸ ì‹œìŠ¤í…œ ìœ„í—˜: {health_score:.1f}%")
        
        with col3:
            last_update = current.get('last_update', 'ì•Œ ìˆ˜ ì—†ìŒ')
            st.info(f"ðŸ• ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: {last_update}")
        
        # ìˆ˜ë™ ì—…ë°ì´íŠ¸ ë²„íŠ¼
        st.subheader("ðŸ”§ ìˆ˜ë™ ì—…ë°ì´íŠ¸")
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            if st.button("âš¡ ë¹ ë¥¸ ì—…ë°ì´íŠ¸ (5ê°œ ETF)"):
                with st.spinner("ì—…ë°ì´íŠ¸ ì‹¤í–‰ ì¤‘..."):
                    try:
                        summary = self.update_manager.batch_update_all_etfs(max_etfs=5, delay_between_updates=0.5)
                        if summary:
                            st.success(f"âœ… ì™„ë£Œ: {summary.success_rate:.1f}% ì„±ê³µ")
                        else:
                            st.error("âŒ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨")
                    except Exception as e:
                        st.error(f"âŒ ì˜¤ë¥˜: {e}")
        
        with col2:
            if st.button("ðŸ”„ ì¼ë°˜ ì—…ë°ì´íŠ¸ (10ê°œ ETF)"):
                with st.spinner("ì—…ë°ì´íŠ¸ ì‹¤í–‰ ì¤‘..."):
                    try:
                        summary = self.update_manager.batch_update_all_etfs(max_etfs=10, delay_between_updates=1.0)
                        if summary:
                            st.success(f"âœ… ì™„ë£Œ: {summary.success_rate:.1f}% ì„±ê³µ")
                        else:
                            st.error("âŒ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨")
                    except Exception as e:
                        st.error(f"âŒ ì˜¤ë¥˜: {e}")
        
        with col3:
            if st.button("ðŸš€ ì „ì²´ ì—…ë°ì´íŠ¸"):
                st.warning("âš ï¸ ì „ì²´ ì—…ë°ì´íŠ¸ëŠ” ì‹œê°„ì´ ì˜¤ëž˜ ê±¸ë¦½ë‹ˆë‹¤")
                # ì „ì²´ ì—…ë°ì´íŠ¸ëŠ” ë³„ë„ í™•ì¸ í•„ìš”
        
        # ì—…ë°ì´íŠ¸ ížˆìŠ¤í† ë¦¬
        st.subheader("ðŸ“‹ ìµœê·¼ ì—…ë°ì´íŠ¸ ížˆìŠ¤í† ë¦¬")
        
        history = status_data.get('recent_history', [])
        if history:
            history_df = pd.DataFrame(history)
            history_df['ì‹œìž‘ì‹œê°„'] = pd.to_datetime(history_df['start_time']).dt.strftime('%m-%d %H:%M')
            history_df['ì„±ê³µë¥ '] = history_df['success_rate'].apply(lambda x: f"{x:.1f}%")
            history_df['ì†Œìš”ì‹œê°„'] = history_df['total_duration'].apply(lambda x: f"{x:.1f}ì´ˆ")
            
            st.dataframe(
                history_df[['ì‹œìž‘ì‹œê°„', 'total_etfs', 'successful_updates', 'failed_updates', 'ì„±ê³µë¥ ', 'ì†Œìš”ì‹œê°„']],
                use_container_width=True
            )
        else:
            st.info("ðŸ“ ì—…ë°ì´íŠ¸ ížˆìŠ¤í† ë¦¬ê°€ ì—†ìŠµë‹ˆë‹¤")
        
        # ìŠ¤ì¼€ì¤„ëŸ¬ ìƒíƒœ
        if self.scheduler and status_data.get('scheduler'):
            st.subheader("â° ìŠ¤ì¼€ì¤„ëŸ¬ ìƒíƒœ")
            
            scheduler_info = status_data['scheduler']
            
            if scheduler_info.get('is_running'):
                st.success("âœ… ìŠ¤ì¼€ì¤„ëŸ¬ ì‹¤í–‰ ì¤‘")
            else:
                st.warning("âš ï¸ ìŠ¤ì¼€ì¤„ëŸ¬ ì¤‘ì§€ë¨")
            
            if 'jobs_info' in scheduler_info:
                jobs_df = pd.DataFrame(scheduler_info['jobs_info'])
                if not jobs_df.empty:
                    st.dataframe(jobs_df, use_container_width=True)
    
    def _render_etf_search(self):
        """ETF ê²€ìƒ‰ íƒ­ ë Œë”ë§"""
        st.header("ðŸ” ETF ê²€ìƒ‰ ë° ë¹„êµ")
        
        # ê²€ìƒ‰ í•„í„°
        st.subheader("ðŸŽ¯ ê²€ìƒ‰ í•„í„°")
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            max_expense = st.slider("ìµœëŒ€ ìš´ìš©ë³´ìˆ˜ (%)", 0.0, 1.0, 0.5, 0.01)
        
        with col2:
            min_aum = st.number_input("ìµœì†Œ ìˆœìžì‚° (ì–µì›)", 0, 100000, 1000, 100)
        
        with col3:
            categories = ['ì „ì²´', 'domestic_equity', 'international_equity', 'bonds', 'alternatives']
            selected_category = st.selectbox("ì¹´í…Œê³ ë¦¬", categories)
        
        # ê²€ìƒ‰ ì‹¤í–‰
        if st.button("ðŸ” ê²€ìƒ‰ ì‹¤í–‰"):
            criteria = {
                'expense_ratio_max': max_expense,
                'aum_min': min_aum,
                'sort_by': 'aum',
                'sort_direction': 'DESC',
                'limit': 20
            }
            
            if selected_category != 'ì „ì²´':
                criteria['category'] = selected_category
            
            search_results = self.screener.screen_by_criteria(criteria)
            
            if not search_results.empty:
                st.subheader(f"ðŸ“Š ê²€ìƒ‰ ê²°ê³¼ ({len(search_results)}ê°œ)")
                
                # ê²°ê³¼ í‘œì‹œ
                display_df = search_results.copy()
                display_df['ìˆœìžì‚°'] = display_df['aum'].apply(lambda x: f"{x:,.0f}ì–µì›")
                display_df['ìš´ìš©ë³´ìˆ˜'] = display_df['expense_ratio'].apply(lambda x: f"{x:.3f}%")
                
                st.dataframe(
                    display_df[['name', 'code', 'category', 'ìˆœìžì‚°', 'ìš´ìš©ë³´ìˆ˜', 'fund_manager']],
                    use_container_width=True
                )
            else:
                st.warning("ðŸ” ê²€ìƒ‰ ì¡°ê±´ì— ë§žëŠ” ETFê°€ ì—†ìŠµë‹ˆë‹¤")
        
        # ETF ë¹„êµ
        st.subheader("âš–ï¸ ETF ë¹„êµ")
        
        etf_codes = st.text_input(
            "ë¹„êµí•  ETF ì½”ë“œ ìž…ë ¥ (ì‰¼í‘œë¡œ êµ¬ë¶„)",
            placeholder="ì˜ˆ: 069500,360750,114260"
        )
        
        if st.button("âš–ï¸ ë¹„êµ ì‹¤í–‰") and etf_codes:
            codes = [code.strip() for code in etf_codes.split(',')]
            comparison_df = self.analyzer.compare_etfs(codes)
            
            if not comparison_df.empty:
                st.subheader("ðŸ“Š ë¹„êµ ê²°ê³¼")
                st.dataframe(comparison_df, use_container_width=True)
                
                # ë¹„êµ ì°¨íŠ¸
                if len(comparison_df) > 1:
                    fig = go.Figure()
                    
                    fig.add_trace(go.Bar(
                        x=comparison_df['name'],
                        y=comparison_df['expense_ratio'],
                        name='ìš´ìš©ë³´ìˆ˜ (%)',
                        yaxis='y'
                    ))
                    
                    fig.add_trace(go.Scatter(
                        x=comparison_df['name'],
                        y=comparison_df['aum'],
                        mode='lines+markers',
                        name='ìˆœìžì‚° (ì–µì›)',
                        yaxis='y2'
                    ))
                    
                    fig.update_layout(
                        title="ETF ë¹„êµ ì°¨íŠ¸",
                        yaxis=dict(title="ìš´ìš©ë³´ìˆ˜ (%)"),
                        yaxis2=dict(title="ìˆœìžì‚° (ì–µì›)", overlaying='y', side='right')
                    )
                    
                    st.plotly_chart(fig, use_container_width=True)
            else:
                st.error("âŒ ë¹„êµí•  ETF ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
    
    def _render_performance_analysis(self):
        """ì„±ê³¼ ë¶„ì„ íƒ­ ë Œë”ë§"""
        st.header("ðŸ“Š ETF ì„±ê³¼ ë¶„ì„")
        
        # ì¹´í…Œê³ ë¦¬ë³„ ë¶„ì„
        st.subheader("ðŸ“ˆ ì¹´í…Œê³ ë¦¬ë³„ íŠ¸ë Œë“œ")
        
        trends = self.analyzer.analyze_category_trends()
        if not trends.empty:
            # ìˆœìžì‚° ê¸°ì¤€ ìƒìœ„ ì¹´í…Œê³ ë¦¬
            fig = px.bar(
                trends.head(10),
                x='category',
                y='total_aum',
                title="ì¹´í…Œê³ ë¦¬ë³„ ì´ ìˆœìžì‚°"
            )
            st.plotly_chart(fig, use_container_width=True)
            
            # ìƒì„¸ í…Œì´ë¸”
            st.dataframe(trends, use_container_width=True)
        
        # ë¹„ìš© íš¨ìœ¨ì„± ë¶„ì„
        st.subheader("ðŸ’° ë¹„ìš© íš¨ìœ¨ì„± ë¶„ì„")
        
        efficiency = self.analyzer.analyze_cost_efficiency()
        if not efficiency.empty:
            # íš¨ìœ¨ì„± ìƒìœ„ ETF
            top_efficient = efficiency.head(15)
            
            fig = px.scatter(
                top_efficient,
                x='expense_ratio',
                y='aum',
                size='efficiency_ratio',
                hover_name='name',
                title="ETF ë¹„ìš© íš¨ìœ¨ì„± (í¬ê¸°: íš¨ìœ¨ì„± ì ìˆ˜)"
            )
            st.plotly_chart(fig, use_container_width=True)
    
    def _render_system_management(self):
        """ì‹œìŠ¤í…œ ê´€ë¦¬ íƒ­ ë Œë”ë§"""
        st.header("âš™ï¸ ì‹œìŠ¤í…œ ê´€ë¦¬")
        
        # ì‹œìŠ¤í…œ ìƒíƒœ
        st.subheader("ðŸ”§ ì‹œìŠ¤í…œ ìƒíƒœ")
        
        health = self.update_manager.quick_health_check()
        if health.get('status') != 'error':
            col1, col2 = st.columns(2)
            
            with col1:
                st.metric("ì´ ETF", f"{health['total_etfs']}ê°œ")
                st.metric("ì—…ë°ì´íŠ¸ëœ ETF", f"{health['updated_etfs']}ê°œ")
                st.metric("ê°€ê²© ì •ë³´ ë³´ìœ ", f"{health['price_available']}ê°œ")
            
            with col2:
                st.metric("24ì‹œê°„ ë‚´ ì—…ë°ì´íŠ¸", f"{health['recent_updates_24h']}ê°œ")
                st.metric("í‰ê·  ì—…ë°ì´íŠ¸ ê²½ê³¼", f"{health['avg_hours_since_update']}ì‹œê°„")
                st.metric("ì‹œìŠ¤í…œ ê±´ê°•ë„", f"{health['health_score']:.1f}%")
        
        # ìŠ¤ì¼€ì¤„ëŸ¬ ê´€ë¦¬
        if self.scheduler:
            st.subheader("â° ìŠ¤ì¼€ì¤„ëŸ¬ ê´€ë¦¬")
            
            scheduler_status = self.scheduler.get_status()
            
            col1, col2 = st.columns(2)
            
            with col1:
                if scheduler_status['is_running']:
                    st.success("âœ… ìŠ¤ì¼€ì¤„ëŸ¬ ì‹¤í–‰ ì¤‘")
                    if st.button("ðŸ›‘ ìŠ¤ì¼€ì¤„ëŸ¬ ì¤‘ì§€"):
                        try:
                            self.scheduler.stop()
                            st.success("âœ… ìŠ¤ì¼€ì¤„ëŸ¬ ì¤‘ì§€ë¨")
                            st.rerun()
                        except Exception as e:
                            st.error(f"âŒ ì¤‘ì§€ ì‹¤íŒ¨: {e}")
                else:
                    st.warning("âš ï¸ ìŠ¤ì¼€ì¤„ëŸ¬ ì¤‘ì§€ë¨")
                    if st.button("ðŸš€ ìŠ¤ì¼€ì¤„ëŸ¬ ì‹œìž‘"):
                        try:
                            self.scheduler.start()
                            st.success("âœ… ìŠ¤ì¼€ì¤„ëŸ¬ ì‹œìž‘ë¨")
                            st.rerun()
                        except Exception as e:
                            st.error(f"âŒ ì‹œìž‘ ì‹¤íŒ¨: {e}")
            
            with col2:
                st.write(f"**ìŠ¤ì¼€ì¤„ëŸ¬ íƒ€ìž…:** {scheduler_status['scheduler_type']}")
                st.write(f"**í™œì„± ìž‘ì—…:** {', '.join(scheduler_status['active_jobs'])}")
        
        # ë°ì´í„°ë² ì´ìŠ¤ ê´€ë¦¬
        st.subheader("ðŸ’¾ ë°ì´í„°ë² ì´ìŠ¤ ê´€ë¦¬")
        
        if st.button("ðŸ”„ ETF ìœ ë‹ˆë²„ìŠ¤ ìž¬êµ¬ì¶•"):
            with st.spinner("ETF ìœ ë‹ˆë²„ìŠ¤ ìž¬êµ¬ì¶• ì¤‘..."):
                try:
                    # ETF ìœ ë‹ˆë²„ìŠ¤ ìž¬ì´ˆê¸°í™” (ì‹¤ì œë¡œëŠ” ë” ë³µìž¡í•œ ë¡œì§ í•„ìš”)
                    st.success("âœ… ETF ìœ ë‹ˆë²„ìŠ¤ ìž¬êµ¬ì¶• ì™„ë£Œ")
                except Exception as e:
                    st.error(f"âŒ ìž¬êµ¬ì¶• ì‹¤íŒ¨: {e}")
        
        # ë¡œê·¸ ë³´ê¸°
        st.subheader("ðŸ“ ì‹œìŠ¤í…œ ë¡œê·¸")
        
        try:
            if os.path.exists("etf_updates.log"):
                with open("etf_updates.log", "r", encoding="utf-8") as f:
                    log_lines = f.readlines()
                    recent_logs = log_lines[-50:]  # ìµœê·¼ 50ì¤„
                    st.text_area("ìµœê·¼ ë¡œê·¸", "".join(recent_logs), height=300)
            else:
                st.info("ðŸ“ ë¡œê·¸ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤")
        except Exception as e:
            st.error(f"âŒ ë¡œê·¸ ì½ê¸° ì‹¤íŒ¨: {e}")
    
    def run_cli_dashboard(self):
        """CLI ë²„ì „ ëŒ€ì‹œë³´ë“œ"""
        print("ðŸ“Š ETF ëª¨ë‹ˆí„°ë§ CLI ëŒ€ì‹œë³´ë“œ")
        print("=" * 60)
        
        while True:
            try:
                print("\nðŸŽ¯ ë©”ë‰´ ì„ íƒ:")
                print("1. ì‹œìž¥ í˜„í™©")
                print("2. ì—…ë°ì´íŠ¸ ìƒíƒœ")
                print("3. ETF ê²€ìƒ‰")
                print("4. ìˆ˜ë™ ì—…ë°ì´íŠ¸")
                print("5. ì‹œìŠ¤í…œ ìƒíƒœ")
                print("6. ì¢…ë£Œ")
                
                choice = input("\nì„ íƒ (1-6): ").strip()
                
                if choice == "1":
                    self._cli_market_overview()
                elif choice == "2":
                    self._cli_update_status()
                elif choice == "3":
                    self._cli_etf_search()
                elif choice == "4":
                    self._cli_manual_update()
                elif choice == "5":
                    self._cli_system_status()
                elif choice == "6":
                    print("ðŸ‘‹ ëŒ€ì‹œë³´ë“œë¥¼ ì¢…ë£Œí•©ë‹ˆë‹¤")
                    break
                else:
                    print("âŒ 1-6 ì¤‘ì—ì„œ ì„ íƒí•´ì£¼ì„¸ìš”")
            
            except KeyboardInterrupt:
                print("\n\nðŸ‘‹ ì‚¬ìš©ìžì— ì˜í•´ ì¢…ë£Œë¨")
                break
            except Exception as e:
                print(f"\nâŒ ì˜¤ë¥˜ ë°œìƒ: {e}")
    
    def _cli_market_overview(self):
        """CLI ì‹œìž¥ í˜„í™©"""
        print("\nðŸ  ETF ì‹œìž¥ í˜„í™©")
        print("-" * 40)
        
        market_data = self.get_market_overview()
        if market_data:
            overview = market_data['overview']
            print(f"ì´ ETF: {overview['total_etfs']}ê°œ")
            print(f"ì´ ìˆœìžì‚°: {overview['total_aum']:,.0f}ì–µì›")
            print(f"í‰ê·  ìš´ìš©ë³´ìˆ˜: {overview['avg_expense_ratio']:.3f}%")
            print(f"24ì‹œê°„ ë‚´ ì—…ë°ì´íŠ¸: {overview['updated_24h']}ê°œ")
            
            print("\nðŸ“Š ì¹´í…Œê³ ë¦¬ë³„ ë¶„í¬:")
            for cat in market_data['category_stats']:
                print(f"- {cat['category']}: {cat['count']}ê°œ, {cat['total_aum']:,.0f}ì–µì›")
    
    def _cli_update_status(self):
        """CLI ì—…ë°ì´íŠ¸ ìƒíƒœ"""
        print("\nðŸ“ˆ ì—…ë°ì´íŠ¸ ìƒíƒœ")
        print("-" * 40)
        
        status_data = self.get_update_status()
        if status_data:
            current = status_data['current_status']
            health = status_data['health']
            
            print(f"ì—…ë°ì´íŠ¸ ì§„í–‰ ì¤‘: {'ì˜ˆ' if current.get('is_updating') else 'ì•„ë‹ˆì˜¤'}")
            print(f"ì‹œìŠ¤í…œ ê±´ê°•ë„: {health.get('health_score', 0):.1f}%")
            print(f"ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: {current.get('last_update', 'ì•Œ ìˆ˜ ì—†ìŒ')}")
            
            history = status_data.get('recent_history', [])
            if history:
                print("\nðŸ“‹ ìµœê·¼ ì—…ë°ì´íŠ¸ ížˆìŠ¤í† ë¦¬:")
                for i, record in enumerate(history[:3]):
                    print(f"{i+1}. {record['start_time'][:19]} - "
                          f"ì„±ê³µë¥  {record['success_rate']:.1f}%")
    
    def _cli_etf_search(self):
        """CLI ETF ê²€ìƒ‰"""
        print("\nðŸ” ETF ê²€ìƒ‰")
        print("-" * 40)
        
        try:
            max_expense = float(input("ìµœëŒ€ ìš´ìš©ë³´ìˆ˜ (%, ì˜ˆ: 0.5): ") or "0.5")
            min_aum = int(input("ìµœì†Œ ìˆœìžì‚° (ì–µì›, ì˜ˆ: 1000): ") or "1000")
            
            criteria = {
                'expense_ratio_max': max_expense,
                'aum_min': min_aum,
                'sort_by': 'aum',
                'limit': 10
            }
            
            results = self.screener.screen_by_criteria(criteria)
            
            if not results.empty:
                print(f"\nðŸ“Š ê²€ìƒ‰ ê²°ê³¼ ({len(results)}ê°œ):")
                for _, etf in results.iterrows():
                    print(f"- {etf['name']} ({etf['code']}): {etf['aum']:,.0f}ì–µì›, {etf['expense_ratio']:.3f}%")
            else:
                print("ðŸ” ê²€ìƒ‰ ì¡°ê±´ì— ë§žëŠ” ETFê°€ ì—†ìŠµë‹ˆë‹¤")
                
        except ValueError:
            print("âŒ ì˜¬ë°”ë¥¸ ìˆ«ìžë¥¼ ìž…ë ¥í•´ì£¼ì„¸ìš”")
    
    def _cli_manual_update(self):
        """CLI ìˆ˜ë™ ì—…ë°ì´íŠ¸"""
        print("\nðŸ”§ ìˆ˜ë™ ì—…ë°ì´íŠ¸")
        print("-" * 40)
        
        print("1. ë¹ ë¥¸ ì—…ë°ì´íŠ¸ (5ê°œ ETF)")
        print("2. ì¼ë°˜ ì—…ë°ì´íŠ¸ (10ê°œ ETF)")
        print("3. ê°œë³„ ETF ì—…ë°ì´íŠ¸")
        
        choice = input("ì„ íƒ: ").strip()
        
        try:
            if choice == "1":
                print("âš¡ ë¹ ë¥¸ ì—…ë°ì´íŠ¸ ì‹¤í–‰ ì¤‘...")
                summary = self.update_manager.batch_update_all_etfs(max_etfs=5)
                if summary:
                    print(f"âœ… ì™„ë£Œ: {summary.success_rate:.1f}% ì„±ê³µ")
            
            elif choice == "2":
                print("ðŸ”„ ì¼ë°˜ ì—…ë°ì´íŠ¸ ì‹¤í–‰ ì¤‘...")
                summary = self.update_manager.batch_update_all_etfs(max_etfs=10)
                if summary:
                    print(f"âœ… ì™„ë£Œ: {summary.success_rate:.1f}% ì„±ê³µ")
            
            elif choice == "3":
                code = input("ETF ì½”ë“œ ìž…ë ¥: ").strip()
                if code:
                    print(f"ðŸ”„ {code} ì—…ë°ì´íŠ¸ ì¤‘...")
                    result = self.update_manager.update_single_etf(code, f"ETF_{code}")
                    print(f"ê²°ê³¼: {result.status}")
                    
        except Exception as e:
            print(f"âŒ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}")
    
    def _cli_system_status(self):
        """CLI ì‹œìŠ¤í…œ ìƒíƒœ"""
        print("\nâš™ï¸ ì‹œìŠ¤í…œ ìƒíƒœ")
        print("-" * 40)
        
        health = self.update_manager.quick_health_check()
        if health.get('status') != 'error':
            print(f"ì´ ETF: {health['total_etfs']}ê°œ")
            print(f"ì—…ë°ì´íŠ¸ëœ ETF: {health['updated_etfs']}ê°œ")
            print(f"ê°€ê²© ì •ë³´ ë³´ìœ : {health['price_available']}ê°œ")
            print(f"24ì‹œê°„ ë‚´ ì—…ë°ì´íŠ¸: {health['recent_updates_24h']}ê°œ")
            print(f"ì‹œìŠ¤í…œ ê±´ê°•ë„: {health['health_score']:.1f}%")
        else:
            print(f"âŒ ì‹œìŠ¤í…œ ìƒíƒœ í™•ì¸ ì‹¤íŒ¨: {health.get('error')}")


# ==========================================
# ì‹¤í–‰ ì˜ˆì œ ë° í…ŒìŠ¤íŠ¸ ì½”ë“œ
# ==========================================

def main():
    """ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜"""
    print("ðŸ“Š ETF ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ")
    print("=" * 60)
    
    dashboard = ETFDashboard()
    
    if STREAMLIT_AVAILABLE:
        print("ðŸŒ Streamlit ì›¹ ëŒ€ì‹œë³´ë“œë¥¼ ì‹œìž‘í•©ë‹ˆë‹¤...")
        print("ë¸Œë¼ìš°ì €ì—ì„œ http://localhost:8501 ìœ¼ë¡œ ì ‘ì†í•˜ì„¸ìš”")
        dashboard.run_streamlit_dashboard()
    else:
        print("ðŸ’» CLI ëŒ€ì‹œë³´ë“œë¥¼ ì‹œìž‘í•©ë‹ˆë‹¤...")
        dashboard.run_cli_dashboard()

if __name__ == "__main__":
    # Streamlitìœ¼ë¡œ ì‹¤í–‰ë˜ëŠ” ê²½ìš°
    if STREAMLIT_AVAILABLE and len(sys.argv) > 1 and 'streamlit' in sys.argv[0]:
        dashboard = ETFDashboard()
        dashboard.run_streamlit_dashboard()
    else:
        main()