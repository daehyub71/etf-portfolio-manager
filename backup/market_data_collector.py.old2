# ==========================================
# data/market_data_collector.py - pykrx ì—°ë™ ì‹œì¥ ë°ì´í„° ìˆ˜ì§‘ê¸°
# ==========================================

import pandas as pd
import numpy as np
import sqlite3
import time
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
import sys
import os
from pathlib import Path

# pykrx import ì‹œë„
try:
    from pykrx import stock
    from pykrx import bond
    PYKRX_AVAILABLE = True
    print("âœ… pykrx ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš© ê°€ëŠ¥")
except ImportError:
    PYKRX_AVAILABLE = False
    print("âš ï¸ pykrx ë¼ì´ë¸ŒëŸ¬ë¦¬ ì—†ìŒ")
    print("pip install pykrx í›„ ì‹¤ì œ ë°ì´í„° ìˆ˜ì§‘ ê°€ëŠ¥")

# ì˜ì—…ì¼ ê³„ì‚°ì„ ìœ„í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬
try:
    import pandas_market_calendars as mcal
    MARKET_CALENDAR_AVAILABLE = True
except ImportError:
    MARKET_CALENDAR_AVAILABLE = False
    print("âš ï¸ pandas_market_calendars ì—†ìŒ - ê¸°ë³¸ ì˜ì—…ì¼ ê³„ì‚° ì‚¬ìš©")

logger = logging.getLogger(__name__)

class MarketDataCollector:
    """pykrx ê¸°ë°˜ ì‹œì¥ ë°ì´í„° ìˆ˜ì§‘ê¸°"""
    
    def __init__(self, db_path: str = "etf_universe.db"):
        self.db_path = db_path
        self.setup_logging()
        
        # API í˜¸ì¶œ ì œí•œì„ ìœ„í•œ ì§€ì—° ì„¤ì •
        self.api_delay = 0.1  # 100ms ì§€ì—°
        self.last_api_call = 0
        
        # ìºì‹œ ì„¤ì •
        self.cache = {}
        self.cache_ttl = 3600  # 1ì‹œê°„ ìºì‹œ
        
        logger.info(f"MarketDataCollector ì´ˆê¸°í™” (DB: {db_path})")
    
    def setup_logging(self):
        """ë¡œê¹… ì„¤ì •"""
        if not logger.handlers:
            handler = logging.StreamHandler()
            formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
            handler.setFormatter(formatter)
            logger.addHandler(handler)
            logger.setLevel(logging.INFO)
    
    def _rate_limit(self):
        """API í˜¸ì¶œ ì œí•œ"""
        now = time.time()
        elapsed = now - self.last_api_call
        if elapsed < self.api_delay:
            time.sleep(self.api_delay - elapsed)
        self.last_api_call = time.time()
    
    def _get_cache_key(self, *args) -> str:
        """ìºì‹œ í‚¤ ìƒì„±"""
        return "_".join(str(arg) for arg in args)
    
    def _is_cache_valid(self, key: str) -> bool:
        """ìºì‹œ ìœ íš¨ì„± í™•ì¸"""
        if key not in self.cache:
            return False
        
        cached_time, _ = self.cache[key]
        return (time.time() - cached_time) < self.cache_ttl
    
    def _get_cache(self, key: str):
        """ìºì‹œì—ì„œ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°"""
        if self._is_cache_valid(key):
            _, data = self.cache[key]
            return data
        return None
    
    def _set_cache(self, key: str, data):
        """ìºì‹œì— ë°ì´í„° ì €ì¥"""
        self.cache[key] = (time.time(), data)
    
    def get_last_business_day(self, date: datetime = None) -> str:
        """ìµœì¢… ì˜ì—…ì¼ ê³„ì‚°"""
        if date is None:
            date = datetime.now()
        
        # í•œêµ­ ì‹œì¥ ê¸°ì¤€ ì˜ì—…ì¼ ê³„ì‚°
        if MARKET_CALENDAR_AVAILABLE:
            try:
                # í•œêµ­ ì‹œì¥ ìº˜ë¦°ë” ì‚¬ìš©
                krx = mcal.get_calendar('XKRX')  # í•œêµ­ê±°ë˜ì†Œ
                
                # ìµœê·¼ 5ì¼ê°„ì˜ ì˜ì—…ì¼ ì¡°íšŒ
                end_date = date
                start_date = date - timedelta(days=10)
                
                business_days = krx.valid_days(
                    start_date=start_date,
                    end_date=end_date
                )
                
                if len(business_days) > 0:
                    last_business_day = business_days[-1].strftime('%Y%m%d')
                    logger.info(f"í•œêµ­ê±°ë˜ì†Œ ì˜ì—…ì¼ ê¸°ì¤€ ìµœì¢…ì¼: {last_business_day}")
                    return last_business_day
                    
            except Exception as e:
                logger.warning(f"ì‹œì¥ ìº˜ë¦°ë” ì‚¬ìš© ì‹¤íŒ¨: {e}")
        
        # ê¸°ë³¸ ì˜ì—…ì¼ ê³„ì‚° (ì£¼ë§ ì œì™¸)
        current_date = date
        while current_date.weekday() >= 5:  # í† ìš”ì¼(5), ì¼ìš”ì¼(6) ì œì™¸
            current_date -= timedelta(days=1)
        
        # í•œêµ­ì˜ ì£¼ìš” ê³µíœ´ì¼ ì²´í¬ (ê°„ë‹¨ ë²„ì „)
        holidays_2024 = [
            '20241225',  # í¬ë¦¬ìŠ¤ë§ˆìŠ¤
            '20241231',  # ì—°ë§
        ]
        
        holidays_2025 = [
            '20250101',  # ì‹ ì •
            '20250127', '20250128', '20250129',  # ì„¤ë‚  ì—°íœ´
            '20250301',  # ì‚¼ì¼ì ˆ
            '20250505',  # ì–´ë¦°ì´ë‚ 
            '20250506',  # ì–´ë¦°ì´ë‚  ëŒ€ì²´íœ´ì¼
            '20250815',  # ê´‘ë³µì ˆ
            '20251003',  # ê°œì²œì ˆ
            '20251006', '20251007', '20251008',  # ì¶”ì„ ì—°íœ´
            '20251009',  # í•œê¸€ë‚ 
            '20251225',  # í¬ë¦¬ìŠ¤ë§ˆìŠ¤
        ]
        
        all_holidays = holidays_2024 + holidays_2025
        
        # ê³µíœ´ì¼ ì²´í¬
        while current_date.strftime('%Y%m%d') in all_holidays:
            current_date -= timedelta(days=1)
            # ì£¼ë§ì´ë©´ ë‹¤ì‹œ ì¡°ì •
            while current_date.weekday() >= 5:
                current_date -= timedelta(days=1)
        
        last_business_day = current_date.strftime('%Y%m%d')
        logger.info(f"ê³„ì‚°ëœ ìµœì¢… ì˜ì—…ì¼: {last_business_day}")
        return last_business_day
    
    def get_all_etf_list(self) -> List[Dict]:
        """ì „ì²´ ETF ì¢…ëª© ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ"""
        cache_key = "all_etf_list"
        cached_data = self._get_cache(cache_key)
        if cached_data:
            logger.info("ìºì‹œì—ì„œ ETF ë¦¬ìŠ¤íŠ¸ ë°˜í™˜")
            return cached_data
        
        if not PYKRX_AVAILABLE:
            logger.warning("pykrx ì—†ìŒ - ê¸°ë³¸ ETF ë¦¬ìŠ¤íŠ¸ ë°˜í™˜")
            return self._get_default_etf_list()
        
        try:
            logger.info("pykrxë¡œ ì „ì²´ ETF ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ ì‹œì‘")
            self._rate_limit()
            
            # ETF ì¢…ëª© ë¦¬ìŠ¤íŠ¸ ê°€ì ¸ì˜¤ê¸°
            etf_tickers = stock.get_etf_ticker_list()
            logger.info(f"ETF ì¢…ëª© {len(etf_tickers)}ê°œ ì¡°íšŒ ì™„ë£Œ")
            
            etf_list = []
            last_business_day = self.get_last_business_day()
            
            # ê° ETFì˜ ê¸°ë³¸ ì •ë³´ ì¡°íšŒ (ë°°ì¹˜ ì²˜ë¦¬)
            batch_size = 10  # í•œ ë²ˆì— ì²˜ë¦¬í•  ì¢…ëª© ìˆ˜
            
            for i in range(0, len(etf_tickers), batch_size):
                batch_tickers = etf_tickers[i:i+batch_size]
                logger.info(f"ETF ì •ë³´ ì¡°íšŒ: {i+1}-{min(i+batch_size, len(etf_tickers))}/{len(etf_tickers)}")
                
                for ticker in batch_tickers:
                    try:
                        self._rate_limit()
                        
                        # ETF ê¸°ë³¸ ì •ë³´ ì¡°íšŒ
                        etf_info = self._get_etf_basic_info(ticker, last_business_day)
                        if etf_info:
                            etf_list.append(etf_info)
                        
                    except Exception as e:
                        logger.error(f"ETF {ticker} ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨: {e}")
                        continue
                
                # ë°°ì¹˜ë§ˆë‹¤ ì¡°ê¸ˆ ë” ê¸´ ì§€ì—°
                if i + batch_size < len(etf_tickers):
                    time.sleep(0.5)
            
            logger.info(f"ETF ì •ë³´ ìˆ˜ì§‘ ì™„ë£Œ: {len(etf_list)}ê°œ")
            
            # ìºì‹œì— ì €ì¥
            self._set_cache(cache_key, etf_list)
            
            return etf_list
            
        except Exception as e:
            logger.error(f"ETF ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ ì‹¤íŒ¨: {e}")
            return self._get_default_etf_list()
    
    def _get_etf_basic_info(self, ticker: str, date: str) -> Optional[Dict]:
        
        try:
        # ì˜ì—…ì¼ ì²´í¬
            if date.weekday() >= 5:  # ì£¼ë§
                logger.warning(f"ì£¼ë§ì…ë‹ˆë‹¤. ë§ˆì§€ë§‰ ì˜ì—…ì¼ ë°ì´í„°ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.")
                date = self._get_last_business_day(date)
            """ê°œë³„ ETF ê¸°ë³¸ ì •ë³´ ì¡°íšŒ"""
            try:
                # ETF ì´ë¦„ ì¡°íšŒ
                try:
                    # ìµœê·¼ ê±°ë˜ì¼ì˜ ë°ì´í„°ë¡œ ì´ë¦„ ì¡°íšŒ
                    df = stock.get_market_ohlcv_by_date(date, date, ticker)
                    if df.empty:
                        return None
                except:
                    return None
                
                # ETF ê¸°ë³¸ ì •ë³´ ìˆ˜ì§‘
                etf_info = {
                    'code': ticker,
                    'name': self._get_etf_name(ticker),
                    'category': self._classify_etf_category(ticker),
                    'market_price': 0,
                    'aum': 0,
                    'last_updated': datetime.now().isoformat()
                }
                
                # ìµœì‹  ê°€ê²© ì •ë³´ ì¡°íšŒ
                try:
                    price_data = stock.get_market_ohlcv_by_date(date, date, ticker)
                    if not price_data.empty:
                        etf_info['market_price'] = float(price_data.iloc[-1]['ì¢…ê°€'])
                        etf_info['volume'] = int(price_data.iloc[-1]['ê±°ë˜ëŸ‰'])
                except Exception as e:
                    logger.debug(f"ETF {ticker} ê°€ê²© ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨: {e}")
                
                # ETF ìˆœìì‚° ì •ë³´ ì¡°íšŒ (ê°€ëŠ¥í•œ ê²½ìš°)
                try:
                    fundamental = stock.get_market_fundamental_by_date(date, date, ticker)
                    if not fundamental.empty:
                        # ì‹œê°€ì´ì•¡ì„ AUM ëŒ€ì‹  ì‚¬ìš©
                        market_cap = fundamental.iloc[-1].get('ì‹œê°€ì´ì•¡', 0)
                        if pd.notna(market_cap):
                            etf_info['aum'] = float(market_cap) / 100000000  # ì–µì› ë‹¨ìœ„ë¡œ ë³€í™˜
                except Exception as e:
                    logger.debug(f"ETF {ticker} í€ë”ë©˜í„¸ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨: {e}")
                
                return etf_info
                
            except Exception as e:
                logger.debug(f"ETF {ticker} ê¸°ë³¸ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨: {e}")
                return None
            
        except Exception as e:
            logger.error(f"ETF {ticker} ë°ì´í„° ì¡°íšŒ ì‹¤íŒ¨: {str(e)}")
            return None  # ë˜ëŠ” ê¸°ë³¸ê°’ ë°˜í™˜
    
    def _get_etf_name(self, ticker: str) -> str:
        """ETF ì´ë¦„ ì¡°íšŒ"""
        try:
            # pykrxì—ì„œ ì¢…ëª©ëª… ì¡°íšŒí•˜ëŠ” ë°©ë²•ì´ ì œí•œì ì´ë¯€ë¡œ
            # ì¼ë°˜ì ì¸ íŒ¨í„´ì„ ê¸°ë°˜ìœ¼ë¡œ ì¶”ì •
            etf_names = {
                '069500': 'KODEX 200',
                '360750': 'TIGER ë¯¸êµ­S&P500',
                '114260': 'KODEX êµ­ê³ ì±„10ë…„',
                '133690': 'KODEX ë‚˜ìŠ¤ë‹¥100',
                '195930': 'KODEX ì„ ì§„êµ­MSCI',
                # ë” ë§ì€ ETF ì´ë¦„ ë§¤í•‘ ì¶”ê°€ ê°€ëŠ¥
            }
            
            return etf_names.get(ticker, f'ETF_{ticker}')
            
        except:
            return f'ETF_{ticker}'
    
    def _classify_etf_category(self, ticker: str) -> str:
        """ETF ì¹´í…Œê³ ë¦¬ ë¶„ë¥˜"""
        # í‹°ì»¤ ì½”ë“œë‚˜ ì´ë¦„ íŒ¨í„´ì„ ê¸°ë°˜ìœ¼ë¡œ ì¹´í…Œê³ ë¦¬ ë¶„ë¥˜
        category_patterns = {
            'domestic_equity': ['069500', '229200', '148020'],  # êµ­ë‚´ ì£¼ì‹
            'foreign_equity': ['360750', '133690', '195930'],   # í•´ì™¸ ì£¼ì‹
            'bonds': ['114260', '305080', '130730'],            # ì±„ê¶Œ
            'alternatives': ['329200', '351590', '132030'],     # ëŒ€ì•ˆíˆ¬ì
            'thematic': ['305540', '091160'],                   # í…Œë§ˆ
        }
        
        for category, tickers in category_patterns.items():
            if ticker in tickers:
                return category
        
        # ê¸°ë³¸ê°’
        return 'domestic_equity'
    
    def _get_default_etf_list(self) -> List[Dict]:
        """ê¸°ë³¸ ETF ë¦¬ìŠ¤íŠ¸ (pykrx ì—†ì„ ë•Œ)"""
        default_etfs = [
            {
                'code': '069500',
                'name': 'KODEX 200',
                'category': 'domestic_equity',
                'market_price': 28400,
                'aum': 20000,
                'last_updated': datetime.now().isoformat()
            },
            {
                'code': '360750',
                'name': 'TIGER ë¯¸êµ­S&P500',
                'category': 'foreign_equity',
                'market_price': 15800,
                'aum': 25000,
                'last_updated': datetime.now().isoformat()
            },
            # ë” ë§ì€ ê¸°ë³¸ ETF ì¶”ê°€...
        ]
        
        logger.info(f"ê¸°ë³¸ ETF ë¦¬ìŠ¤íŠ¸ ë°˜í™˜: {len(default_etfs)}ê°œ")
        return default_etfs
    
    def fetch_etf_price_data(self, ticker: str, period: str = "1m") -> pd.DataFrame:
        """ETF ê°€ê²© ë°ì´í„° ì¡°íšŒ"""
        cache_key = self._get_cache_key("price", ticker, period)
        cached_data = self._get_cache(cache_key)
        if cached_data is not None:
            return cached_data
        
        if not PYKRX_AVAILABLE:
            logger.warning(f"pykrx ì—†ìŒ - {ticker} ë”ë¯¸ ë°ì´í„° ë°˜í™˜")
            return self._generate_dummy_price_data(ticker, period)
        
        try:
            # ê¸°ê°„ ê³„ì‚°
            end_date = datetime.now()
            
            if period == "1d":
                start_date = end_date - timedelta(days=1)
            elif period == "1w":
                start_date = end_date - timedelta(days=7)
            elif period == "1m":
                start_date = end_date - timedelta(days=30)
            elif period == "3m":
                start_date = end_date - timedelta(days=90)
            elif period == "1y":
                start_date = end_date - timedelta(days=365)
            else:
                start_date = end_date - timedelta(days=30)
            
            # ì˜ì—…ì¼ë¡œ ì¡°ì •
            start_date_str = self.get_last_business_day(start_date)
            end_date_str = self.get_last_business_day(end_date)
            
            logger.info(f"ETF {ticker} ê°€ê²© ë°ì´í„° ì¡°íšŒ: {start_date_str} ~ {end_date_str}")
            
            self._rate_limit()
            
            # pykrxë¡œ OHLCV ë°ì´í„° ì¡°íšŒ
            df = stock.get_market_ohlcv_by_date(start_date_str, end_date_str, ticker)
            
            if df.empty:
                logger.warning(f"ETF {ticker} ê°€ê²© ë°ì´í„° ì—†ìŒ")
                return pd.DataFrame()
            
            # ì»¬ëŸ¼ëª… ì˜ì–´ë¡œ ë³€ê²½
            df.columns = ['open', 'high', 'low', 'close', 'volume']
            df.index.name = 'date'
            df = df.reset_index()
            
            # ë‚ ì§œ í˜•ì‹ ë³€í™˜
            df['date'] = pd.to_datetime(df['date'])
            
            # ìˆ˜ìµë¥  ê³„ì‚°
            df['returns'] = df['close'].pct_change()
            
            logger.info(f"ETF {ticker} ê°€ê²© ë°ì´í„° ì¡°íšŒ ì™„ë£Œ: {len(df)}ê±´")
            
            # ìºì‹œì— ì €ì¥
            self._set_cache(cache_key, df)
            
            return df
            
        except Exception as e:
            logger.error(f"ETF {ticker} ê°€ê²© ë°ì´í„° ì¡°íšŒ ì‹¤íŒ¨: {e}")
            return self._generate_dummy_price_data(ticker, period)
    
    def _generate_dummy_price_data(self, ticker: str, period: str) -> pd.DataFrame:
        """ë”ë¯¸ ê°€ê²© ë°ì´í„° ìƒì„±"""
        # ê¸°ê°„ì— ë”°ë¥¸ ë°ì´í„° í¬ì¸íŠ¸ ìˆ˜
        period_days = {
            "1d": 1,
            "1w": 7,
            "1m": 30,
            "3m": 90,
            "1y": 365
        }
        
        days = period_days.get(period, 30)
        
        # ê¸°ë³¸ ê°€ê²© ì„¤ì •
        base_prices = {
            '069500': 28400,
            '360750': 15800,
            '114260': 108500,
        }
        
        base_price = base_prices.get(ticker, 10000)
        
        # ë”ë¯¸ ë°ì´í„° ìƒì„±
        dates = pd.date_range(end=datetime.now(), periods=days, freq='D')
        
        # ëœë¤ ê°€ê²© ë³€ë™ (ì‹œë“œ ê³ ì •ìœ¼ë¡œ ì¼ê´€ì„± ìœ ì§€)
        np.random.seed(hash(ticker) % 1000)
        returns = np.random.normal(0.001, 0.02, days)  # í‰ê·  0.1%, ë³€ë™ì„± 2%
        
        prices = [base_price]
        for r in returns[1:]:
            prices.append(prices[-1] * (1 + r))
        
        # DataFrame ìƒì„±
        df = pd.DataFrame({
            'date': dates,
            'open': prices,
            'high': [p * (1 + abs(np.random.normal(0, 0.01))) for p in prices],
            'low': [p * (1 - abs(np.random.normal(0, 0.01))) for p in prices],
            'close': prices,
            'volume': np.random.randint(10000, 100000, days),
            'returns': [0] + returns[1:].tolist()
        })
        
        return df
    
    def calculate_performance_metrics(self, price_data: pd.DataFrame) -> Dict:
        """ì„±ê³¼ ì§€í‘œ ê³„ì‚°"""
        if price_data.empty:
            return {'data_points': 0}
        
        try:
            returns = price_data['returns'].dropna()
            
            if len(returns) == 0:
                return {'data_points': len(price_data)}
            
            # ê¸°ë³¸ ì„±ê³¼ ì§€í‘œ ê³„ì‚°
            metrics = {
                'data_points': len(price_data),
                'total_return': (price_data['close'].iloc[-1] / price_data['close'].iloc[0] - 1) * 100,
                'volatility': returns.std() * np.sqrt(252) * 100,  # ì—°í™˜ì‚° ë³€ë™ì„±
                'sharpe_ratio': (returns.mean() / returns.std() * np.sqrt(252)) if returns.std() > 0 else 0,
                'max_drawdown': self._calculate_max_drawdown(price_data['close']),
                'avg_volume': price_data['volume'].mean(),
                'current_price': price_data['close'].iloc[-1]
            }
            
            return metrics
            
        except Exception as e:
            logger.error(f"ì„±ê³¼ ì§€í‘œ ê³„ì‚° ì‹¤íŒ¨: {e}")
            return {'data_points': len(price_data)}
    
    def _calculate_max_drawdown(self, prices: pd.Series) -> float:
        """ìµœëŒ€ ë‚™í­ ê³„ì‚°"""
        try:
            cumulative = (1 + prices.pct_change()).cumprod()
            running_max = cumulative.expanding().max()
            drawdown = (cumulative - running_max) / running_max
            return abs(drawdown.min()) * 100
        except:
            return 0.0
    
    def fetch_etf_info(self, ticker: str) -> Dict:
        """ETF ì¶”ê°€ ì •ë³´ ì¡°íšŒ"""
        cache_key = self._get_cache_key("info", ticker)
        cached_data = self._get_cache(cache_key)
        if cached_data:
            return cached_data
        
        try:
            last_business_day = self.get_last_business_day()
            
            info = {
                'ticker': ticker,
                'current_price': 0,
                'nav': 0,
                'premium_discount': 0,
                'volume': 0,
                'last_updated': datetime.now().isoformat()
            }
            
            if PYKRX_AVAILABLE:
                try:
                    self._rate_limit()
                    
                    # ìµœì‹  ê°€ê²© ì •ë³´
                    price_data = stock.get_market_ohlcv_by_date(last_business_day, last_business_day, ticker)
                    if not price_data.empty:
                        info['current_price'] = float(price_data.iloc[-1]['ì¢…ê°€'])
                        info['volume'] = int(price_data.iloc[-1]['ê±°ë˜ëŸ‰'])
                    
                    # ETF íŠ¹í™” ì •ë³´ (ê°€ëŠ¥í•œ ê²½ìš°)
                    try:
                        # ETF NAV ì •ë³´ëŠ” ë³„ë„ APIê°€ í•„ìš”í•  ìˆ˜ ìˆìŒ
                        info['nav'] = info['current_price']  # ì„ì‹œë¡œ í˜„ì¬ê°€ ì‚¬ìš©
                        info['premium_discount'] = 0  # ê³„ì‚° í•„ìš”
                    except:
                        pass
                        
                except Exception as e:
                    logger.debug(f"ETF {ticker} ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨: {e}")
            
            # ìºì‹œì— ì €ì¥
            self._set_cache(cache_key, info)
            
            return info
            
        except Exception as e:
            logger.error(f"ETF {ticker} ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨: {e}")
            return {
                'ticker': ticker,
                'current_price': 10000,
                'nav': 10000,
                'premium_discount': 0,
                'volume': 0,
                'last_updated': datetime.now().isoformat()
            }
    
    def update_etf_database(self, etf_list: List[Dict]) -> bool:
        """ETF ì •ë³´ë¥¼ ë°ì´í„°ë² ì´ìŠ¤ì— ì—…ë°ì´íŠ¸"""
        try:
            conn = sqlite3.connect(self.db_path)
            
            # í…Œì´ë¸” ì¡´ì¬ í™•ì¸ ë° ìƒì„±
            conn.execute('''
                CREATE TABLE IF NOT EXISTS etf_info (
                    code TEXT PRIMARY KEY,
                    name TEXT NOT NULL,
                    category TEXT,
                    market_price REAL DEFAULT 0,
                    aum REAL DEFAULT 0,
                    volume INTEGER DEFAULT 0,
                    last_updated TEXT
                )
            ''')
            
            updated_count = 0
            
            for etf in etf_list:
                conn.execute('''
                    INSERT OR REPLACE INTO etf_info 
                    (code, name, category, market_price, aum, volume, last_updated)
                    VALUES (?, ?, ?, ?, ?, ?, ?)
                ''', (
                    etf['code'],
                    etf['name'],
                    etf.get('category', 'unknown'),
                    etf.get('market_price', 0),
                    etf.get('aum', 0),
                    etf.get('volume', 0),
                    etf['last_updated']
                ))
                updated_count += 1
            
            conn.commit()
            conn.close()
            
            logger.info(f"ETF ë°ì´í„°ë² ì´ìŠ¤ ì—…ë°ì´íŠ¸ ì™„ë£Œ: {updated_count}ê°œ")
            return True
            
        except Exception as e:
            logger.error(f"ETF ë°ì´í„°ë² ì´ìŠ¤ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}")
            return False
    
    def get_market_status(self) -> Dict:
        """ì‹œì¥ ìƒíƒœ ì •ë³´"""
        now = datetime.now()
        last_business_day = self.get_last_business_day()
        
        # ì‹œì¥ ì‹œê°„ ì²´í¬ (í•œêµ­ ì‹œì¥: 09:00-15:30)
        market_open = now.replace(hour=9, minute=0, second=0, microsecond=0)
        market_close = now.replace(hour=15, minute=30, second=0, microsecond=0)
        
        is_trading_hours = market_open <= now <= market_close and now.weekday() < 5
        
        return {
            'current_time': now.isoformat(),
            'last_business_day': last_business_day,
            'is_trading_hours': is_trading_hours,
            'market_open': market_open.time().isoformat(),
            'market_close': market_close.time().isoformat(),
            'is_weekend': now.weekday() >= 5,
            'pykrx_available': PYKRX_AVAILABLE
        }


# ==========================================
# ì‹¤í–‰ ì˜ˆì œ ë° í…ŒìŠ¤íŠ¸ ì½”ë“œ
# ==========================================

if __name__ == "__main__":
    print("ğŸ“Š pykrx ê¸°ë°˜ ì‹œì¥ ë°ì´í„° ìˆ˜ì§‘ê¸° í…ŒìŠ¤íŠ¸")
    print("=" * 60)
    
    # ìˆ˜ì§‘ê¸° ì´ˆê¸°í™”
    collector = MarketDataCollector()
    
    # ì‹œì¥ ìƒíƒœ í™•ì¸
    print("\nğŸ“ˆ ì‹œì¥ ìƒíƒœ:")
    market_status = collector.get_market_status()
    print(f"í˜„ì¬ ì‹œê°„: {market_status['current_time'][:19]}")
    print(f"ìµœì¢… ì˜ì—…ì¼: {market_status['last_business_day']}")
    print(f"ê±°ë˜ ì‹œê°„: {'ì˜ˆ' if market_status['is_trading_hours'] else 'ì•„ë‹ˆì˜¤'}")
    print(f"ì£¼ë§: {'ì˜ˆ' if market_status['is_weekend'] else 'ì•„ë‹ˆì˜¤'}")
    print(f"pykrx ì‚¬ìš© ê°€ëŠ¥: {'ì˜ˆ' if market_status['pykrx_available'] else 'ì•„ë‹ˆì˜¤'}")
    
    # ETF ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ í…ŒìŠ¤íŠ¸
    print(f"\nğŸ“‹ ETF ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ í…ŒìŠ¤íŠ¸:")
    etf_list = collector.get_all_etf_list()
    print(f"ì´ ETF ê°œìˆ˜: {len(etf_list)}")
    
    if etf_list:
        print(f"\nìƒìœ„ 5ê°œ ETF:")
        for i, etf in enumerate(etf_list[:5]):
            print(f"{i+1}. {etf['name']} ({etf['code']}): {etf['market_price']:,.0f}ì›")
    
    # ê°œë³„ ETF ê°€ê²© ë°ì´í„° í…ŒìŠ¤íŠ¸
    if etf_list:
        test_ticker = etf_list[0]['code']
        print(f"\nğŸ“Š {test_ticker} ê°€ê²© ë°ì´í„° í…ŒìŠ¤íŠ¸:")
        
        price_data = collector.fetch_etf_price_data(test_ticker, "1m")
        if not price_data.empty:
            print(f"ë°ì´í„° ê¸°ê°„: {price_data['date'].min().date()} ~ {price_data['date'].max().date()}")
            print(f"ë°ì´í„° í¬ì¸íŠ¸: {len(price_data)}ê°œ")
            print(f"ìµœì‹  ê°€ê²©: {price_data['close'].iloc[-1]:,.0f}ì›")
            
            # ì„±ê³¼ ì§€í‘œ ê³„ì‚°
            metrics = collector.calculate_performance_metrics(price_data)
            print(f"ì´ ìˆ˜ìµë¥ : {metrics.get('total_return', 0):.2f}%")
            print(f"ë³€ë™ì„±: {metrics.get('volatility', 0):.2f}%")
        else:
            print("ê°€ê²© ë°ì´í„° ì—†ìŒ")
    
    print(f"\nâœ… ì‹œì¥ ë°ì´í„° ìˆ˜ì§‘ê¸° í…ŒìŠ¤íŠ¸ ì™„ë£Œ!")